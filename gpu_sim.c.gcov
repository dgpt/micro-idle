        -:    0:Source:/home/dgpt/code/games/micro-idle/game/gpu_sim.c
        -:    0:Graph:build/CMakeFiles/tests.dir/game/gpu_sim.c.gcno
        -:    0:Data:build/CMakeFiles/tests.dir/game/gpu_sim.c.gcda
        -:    0:Runs:2
        -:    1:#include "game/gpu_sim.h"
        -:    2:
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:#include <stdio.h>
        -:    6:#include <stdint.h>
        -:    7:
        -:    8:#include "raymath.h"
        -:    9:#include "external/glad.h"
        -:   10:#include "rlgl.h"
        -:   11:
        -:   12:#define GPU_WORKGROUP_SIZE 256
        -:   13:#define GRID_W 128
        -:   14:#define GRID_H 128
        -:   15:#define GRID_CELLS (GRID_W * GRID_H)
        -:   16:
        -:   17:typedef struct GpuEntity {
        -:   18:    float pos[4];
        -:   19:    float vel[4];
        -:   20:    float color[4];
        -:   21:    float params[4];
        -:   22:} GpuEntity;
        -:   23:
        -:   24:#ifdef GPU_SIM_TESTING
        -:   25:static int gpu_sim_fail_mode = 0;
        -:   26:
function gpu_sim_test_set_fail_mode called 14 returned 100% blocks executed 100%
       14:   27:void gpu_sim_test_set_fail_mode(int mode) {
       14:   28:    gpu_sim_fail_mode = mode;
       14:   29:}
        -:   30:#endif
        -:   31:
        -:   32:static const char *kShaderSimInsertName = "sim_insert.comp";
        -:   33:static const char *kShaderSimCollideName = "sim_collide.comp";
        -:   34:static const char *kShaderMicrobeVertName = "microbe.vert";
        -:   35:static const char *kShaderMicrobeFragName = "microbe.frag";
        -:   36:
function load_shader_source called 44 returned 100% blocks executed 75%
       44:   37:static char *load_shader_source(const char *file_name, char *resolved, size_t resolved_size) {
       44:   38:    const char *roots[] = {"data/shaders", "../data/shaders", "../../data/shaders"};
        -:   39:    char path[512];
      44*:   40:    for (size_t i = 0; i < sizeof(roots) / sizeof(roots[0]); ++i) {
branch  0 taken 44
branch  1 taken 0 (fallthrough)
       44:   41:        int written = snprintf(path, sizeof(path), "%s/%s", roots[i], file_name);
      44*:   42:        if (written <= 0 || (size_t)written >= sizeof(path)) continue;
branch  0 taken 44 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 44
       44:   43:        char *text = LoadFileText(path);
call    0 returned 44
       44:   44:        if (text) {
branch  0 taken 44 (fallthrough)
branch  1 taken 0
       44:   45:            if (resolved && resolved_size > 0) {
branch  0 taken 44 (fallthrough)
branch  1 taken 0
branch  2 taken 44 (fallthrough)
branch  3 taken 0
       44:   46:                snprintf(resolved, resolved_size, "%s", path);
        -:   47:            }
       44:   48:            return text;
        -:   49:        }
        -:   50:    }
    #####:   51:    fprintf(stderr, "failed to load shader file: %s\n", file_name);
call    0 never executed
    #####:   52:    return NULL;
        -:   53:}
        -:   54:
function resolve_shader_path called 40 returned 100% blocks executed 75%
       40:   55:static bool resolve_shader_path(const char *file_name, char *resolved, size_t resolved_size) {
       40:   56:    const char *roots[] = {"data/shaders", "../data/shaders", "../../data/shaders"};
        -:   57:    char path[512];
      40*:   58:    for (size_t i = 0; i < sizeof(roots) / sizeof(roots[0]); ++i) {
branch  0 taken 40
branch  1 taken 0 (fallthrough)
       40:   59:        int written = snprintf(path, sizeof(path), "%s/%s", roots[i], file_name);
      40*:   60:        if (written <= 0 || (size_t)written >= sizeof(path)) continue;
branch  0 taken 40 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 40
       40:   61:        if (FileExists(path)) {
call    0 returned 40
branch  1 taken 40 (fallthrough)
branch  2 taken 0
       40:   62:            if (resolved && resolved_size > 0) {
branch  0 taken 40 (fallthrough)
branch  1 taken 0
branch  2 taken 40 (fallthrough)
branch  3 taken 0
       40:   63:                snprintf(resolved, resolved_size, "%s", path);
        -:   64:            }
       40:   65:            return true;
        -:   66:        }
        -:   67:    }
    #####:   68:    fprintf(stderr, "shader path not found: %s\n", file_name);
call    0 never executed
    #####:   69:    return false;
        -:   70:}
        -:   71:
function compile_shader_from_file called 44 returned 100% blocks executed 78%
       44:   72:static unsigned int compile_shader_from_file(GLenum type, const char *file_name) {
       44:   73:    char resolved[512] = {0};
       44:   74:    bool from_file = true;
       44:   75:    char *source = load_shader_source(file_name, resolved, sizeof(resolved));
call    0 returned 44
        -:   76:#ifdef GPU_SIM_TESTING
       44:   77:    if (gpu_sim_fail_mode == 1) {
branch  0 taken 4 (fallthrough)
branch  1 taken 40
        4:   78:        if (source) UnloadFileText(source);
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 returned 4
        4:   79:        source = strdup("invalid shader");
        4:   80:        from_file = false;
        -:   81:    }
        -:   82:#endif
       44:   83:    if (!source) {
branch  0 taken 0 (fallthrough)
branch  1 taken 44
    #####:   84:        return 0;
        -:   85:    }
       44:   86:    unsigned int shader = glCreateShader(type);
call    0 returned 44
       44:   87:    if (!shader) {
branch  0 taken 0 (fallthrough)
branch  1 taken 44
    #####:   88:        if (from_file) UnloadFileText(source); else free(source);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   89:        return 0;
        -:   90:    }
       44:   91:    const char *src_ptr = source;
       44:   92:    glShaderSource(shader, 1, &src_ptr, NULL);
call    0 returned 44
       44:   93:    glCompileShader(shader);
call    0 returned 44
       44:   94:    GLint compiled = 0;
       44:   95:    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
call    0 returned 44
       44:   96:    if (!compiled) {
branch  0 taken 4 (fallthrough)
branch  1 taken 40
        4:   97:        GLint length = 0;
        4:   98:        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &length);
call    0 returned 4
        4:   99:        if (length > 1) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:  100:            char *log = (char *)malloc((size_t)length);
        4:  101:            if (log) {
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:  102:                glGetShaderInfoLog(shader, length, NULL, log);
call    0 returned 4
       4*:  103:                fprintf(stderr, "shader compile failed (%s): %s\n", resolved[0] ? resolved : file_name, log);
branch  0 taken 4 (fallthrough)
branch  1 taken 0
call    2 returned 4
        4:  104:                free(log);
        -:  105:            }
        -:  106:        }
        4:  107:        glDeleteShader(shader);
call    0 returned 4
       4*:  108:        if (from_file) UnloadFileText(source); else free(source);
branch  0 taken 0 (fallthrough)
branch  1 taken 4
call    2 never executed
        4:  109:        return 0;
        -:  110:    }
      40*:  111:    if (from_file) UnloadFileText(source); else free(source);
branch  0 taken 40 (fallthrough)
branch  1 taken 0
call    2 returned 40
       40:  112:    return shader;
        -:  113:}
        -:  114:
        -:  115:
function link_program called 40 returned 100% blocks executed 76%
       40:  116:static unsigned int link_program(unsigned int shader) {
       40:  117:    unsigned int program = glCreateProgram();
call    0 returned 40
       40:  118:    if (!program) {
branch  0 taken 0 (fallthrough)
branch  1 taken 40
    #####:  119:        return 0;
        -:  120:    }
       40:  121:    if (shader) {
branch  0 taken 40 (fallthrough)
branch  1 taken 0
       40:  122:        glAttachShader(program, shader);
call    0 returned 40
        -:  123:    }
       40:  124:    glLinkProgram(program);
call    0 returned 40
       40:  125:    GLint linked = 0;
       40:  126:    glGetProgramiv(program, GL_LINK_STATUS, &linked);
call    0 returned 40
        -:  127:#ifdef GPU_SIM_TESTING
       40:  128:    if (gpu_sim_fail_mode == 2) {
branch  0 taken 4 (fallthrough)
branch  1 taken 36
        4:  129:        linked = 0;
        -:  130:    }
        -:  131:#endif
       40:  132:    if (!linked) {
branch  0 taken 4 (fallthrough)
branch  1 taken 36
        4:  133:        GLint length = 0;
        4:  134:        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &length);
call    0 returned 4
        4:  135:        if (length > 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:  136:            char *log = (char *)malloc((size_t)length);
    #####:  137:            if (log) {
branch  0 never executed
branch  1 never executed
    #####:  138:                glGetProgramInfoLog(program, length, NULL, log);
call    0 never executed
    #####:  139:                fprintf(stderr, "program link failed: %s\n", log);
call    0 never executed
    #####:  140:                free(log);
        -:  141:            }
        -:  142:        }
        4:  143:        glDeleteProgram(program);
call    0 returned 4
        4:  144:        return 0;
        -:  145:    }
       36:  146:    return program;
        -:  147:}
        -:  148:
function init_quad called 18 returned 100% blocks executed 100%
       18:  149:static void init_quad(GpuSim *sim) {
       18:  150:    float verts[] = {
        -:  151:        -0.5f, 0.0f, -0.5f,
        -:  152:         0.5f, 0.0f, -0.5f,
        -:  153:         0.5f, 0.0f,  0.5f,
        -:  154:        -0.5f, 0.0f,  0.5f
        -:  155:    };
       18:  156:    unsigned short indices[] = {0, 1, 2, 2, 3, 0};
        -:  157:
       18:  158:    glGenVertexArrays(1, &sim->vao);
call    0 returned 18
       18:  159:    glBindVertexArray(sim->vao);
call    0 returned 18
        -:  160:
       18:  161:    glGenBuffers(1, &sim->vbo);
call    0 returned 18
       18:  162:    glBindBuffer(GL_ARRAY_BUFFER, sim->vbo);
call    0 returned 18
       18:  163:    glBufferData(GL_ARRAY_BUFFER, sizeof(verts), verts, GL_STATIC_DRAW);
call    0 returned 18
        -:  164:
       18:  165:    glGenBuffers(1, &sim->ebo);
call    0 returned 18
       18:  166:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sim->ebo);
call    0 returned 18
       18:  167:    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
call    0 returned 18
        -:  168:
       18:  169:    glEnableVertexAttribArray(0);
call    0 returned 18
       18:  170:    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *)0);
call    0 returned 18
        -:  171:
       18:  172:    glBindVertexArray(0);
call    0 returned 18
        -:  173:
       18:  174:    sim->indices_count = 6;
       18:  175:}
        -:  176:
function init_entities called 18 returned 100% blocks executed 100%
       18:  177:static bool init_entities(GpuSim *sim, int count) {
       18:  178:    GpuEntity *entities = NULL;
        -:  179:#ifdef GPU_SIM_TESTING
       18:  180:    if (gpu_sim_fail_mode != 3) {
branch  0 taken 16 (fallthrough)
branch  1 taken 2
       16:  181:        entities = (GpuEntity *)malloc(sizeof(GpuEntity) * (size_t)count);
        -:  182:    }
        -:  183:#else
        -:  184:    entities = (GpuEntity *)malloc(sizeof(GpuEntity) * (size_t)count);
        -:  185:#endif
       18:  186:    if (!entities) {
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2:  187:        return false;
        -:  188:    }
        -:  189:
        -:  190:    static const float palette[4][3] = {
        -:  191:        {0.28f, 0.82f, 0.52f}, // coccus
        -:  192:        {0.18f, 0.64f, 0.86f}, // bacillus
        -:  193:        {0.98f, 0.78f, 0.26f}, // vibrio
        -:  194:        {0.86f, 0.32f, 0.88f}  // spirillum
        -:  195:    };
        -:  196:    static const float base_radius[4] = {0.75f, 1.2f, 1.05f, 0.95f};
        -:  197:    static const float var_radius[4] = {0.45f, 0.4f, 0.45f, 0.4f};
        -:  198:
  2082092:  199:    for (int i = 0; i < count; ++i) {
branch  0 taken 2082076
branch  1 taken 16 (fallthrough)
  2082076:  200:        uint32_t seed = (uint32_t)(i + 1) * 2654435761u;
  2082076:  201:        seed ^= seed >> 16;
  2082076:  202:        float r1 = (float)(seed & 0xFFFFu) / 65535.0f;
  2082076:  203:        seed = seed * 2246822519u + 3266489917u;
  2082076:  204:        float r2 = (float)(seed & 0xFFFFu) / 65535.0f;
  2082076:  205:        seed = seed * 3266489917u + 668265263u;
  2082076:  206:        float r3 = (float)(seed & 0xFFFFu) / 65535.0f;
  2082076:  207:        int type = (int)(seed % 4u);
  2082076:  208:        float px = ((float)(i % 1000) / 1000.0f - 0.5f) * 24.0f;
  2082076:  209:        float pz = ((float)(i / 1000) / 1000.0f - 0.5f) * 20.0f;
  2082076:  210:        entities[i].pos[0] = px;
  2082076:  211:        entities[i].pos[1] = 0.0f;
  2082076:  212:        entities[i].pos[2] = pz;
  2082076:  213:        entities[i].pos[3] = 1.0f;
  2082076:  214:        entities[i].vel[0] = (r1 - 0.5f) * 0.3f;
  2082076:  215:        entities[i].vel[1] = 0.0f;
  2082076:  216:        entities[i].vel[2] = (r2 - 0.5f) * 0.3f;
  2082076:  217:        entities[i].vel[3] = 0.0f;
  2082076:  218:        entities[i].color[0] = palette[type][0] + (r3 - 0.5f) * 0.08f;
  2082076:  219:        entities[i].color[1] = palette[type][1] + (r1 - 0.5f) * 0.08f;
  2082076:  220:        entities[i].color[2] = palette[type][2] + (r2 - 0.5f) * 0.08f;
  2082076:  221:        entities[i].color[3] = 0.62f + (r1 - 0.5f) * 0.1f;
        -:  222:
  2082076:  223:        entities[i].params[0] = base_radius[type] + r3 * var_radius[type];
  2082076:  224:        entities[i].params[1] = 0.0f;
  2082076:  225:        entities[i].params[2] = (float)type;
  2082076:  226:        entities[i].params[3] = r2;
        -:  227:    }
        -:  228:
       16:  229:    glGenBuffers(1, &sim->ssbo);
call    0 returned 16
       16:  230:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, sim->ssbo);
call    0 returned 16
       16:  231:    glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(GpuEntity) * (size_t)count, entities, GL_DYNAMIC_DRAW);
call    0 returned 16
       16:  232:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, sim->ssbo);
call    0 returned 16
       16:  233:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
call    0 returned 16
        -:  234:
       16:  235:    glGenBuffers(1, &sim->ssbo_head);
call    0 returned 16
       16:  236:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, sim->ssbo_head);
call    0 returned 16
       16:  237:    glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(int) * GRID_CELLS, NULL, GL_DYNAMIC_DRAW);
call    0 returned 16
       16:  238:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, sim->ssbo_head);
call    0 returned 16
        -:  239:
       16:  240:    glGenBuffers(1, &sim->ssbo_next);
call    0 returned 16
       16:  241:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, sim->ssbo_next);
call    0 returned 16
       16:  242:    glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(int) * (size_t)count, NULL, GL_DYNAMIC_DRAW);
call    0 returned 16
       16:  243:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, sim->ssbo_next);
call    0 returned 16
       16:  244:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
call    0 returned 16
        -:  245:
       16:  246:    free(entities);
       16:  247:    return true;
        -:  248:}
        -:  249:
function validate_gpu_sim_limits called 26 returned 100% blocks executed 88%
       26:  250:static bool validate_gpu_sim_limits(int count) {
       26:  251:    GLint max_storage = 0;
       26:  252:    GLint max_ssbo = 0;
       26:  253:    glGetIntegerv(GL_MAX_SHADER_STORAGE_BLOCK_SIZE, &max_storage);
call    0 returned 26
       26:  254:    glGetIntegerv(GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS, &max_ssbo);
call    0 returned 26
       26:  255:    if (max_storage <= 0 || max_ssbo < 3) {
branch  0 taken 26 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 26
    #####:  256:        return false;
        -:  257:    }
       26:  258:    size_t bytes = sizeof(GpuEntity) * (size_t)count;
       26:  259:    return bytes <= (size_t)max_storage;
        -:  260:}
        -:  261:
function gpu_sim_init called 26 returned 100% blocks executed 91%
       26:  262:bool gpu_sim_init(GpuSim *sim, int entity_count) {
       26:  263:    memset(sim, 0, sizeof(*sim));
       26:  264:    sim->entity_count = entity_count;
       26:  265:    sim->active_count = entity_count;
        -:  266:
       26:  267:    if (!gpu_sim_supported()) {
call    0 returned 26
branch  1 taken 0 (fallthrough)
branch  2 taken 26
    #####:  268:        return false;
        -:  269:    }
       26:  270:    if (!validate_gpu_sim_limits(entity_count)) {
call    0 returned 26
branch  1 taken 2 (fallthrough)
branch  2 taken 24
        2:  271:        return false;
        -:  272:    }
        -:  273:
       24:  274:    unsigned int cs_insert = compile_shader_from_file(GL_COMPUTE_SHADER, kShaderSimInsertName);
call    0 returned 24
       24:  275:    if (cs_insert == 0) return false;
branch  0 taken 4 (fallthrough)
branch  1 taken 20
       20:  276:    sim->sim_insert_program = link_program(cs_insert);
call    0 returned 20
       20:  277:    glDeleteShader(cs_insert);
call    0 returned 20
        -:  278:
       20:  279:    unsigned int cs_collide = compile_shader_from_file(GL_COMPUTE_SHADER, kShaderSimCollideName);
call    0 returned 20
      20*:  280:    if (cs_collide == 0) return false;
branch  0 taken 0 (fallthrough)
branch  1 taken 20
       20:  281:    sim->sim_collide_program = link_program(cs_collide);
call    0 returned 20
       20:  282:    glDeleteShader(cs_collide);
call    0 returned 20
        -:  283:
       20:  284:    char vert_path[512] = {0};
       20:  285:    char frag_path[512] = {0};
      20*:  286:    if (!resolve_shader_path(kShaderMicrobeVertName, vert_path, sizeof(vert_path))) return false;
call    0 returned 20
branch  1 taken 0 (fallthrough)
branch  2 taken 20
      20*:  287:    if (!resolve_shader_path(kShaderMicrobeFragName, frag_path, sizeof(frag_path))) return false;
call    0 returned 20
branch  1 taken 0 (fallthrough)
branch  2 taken 20
       20:  288:    sim->render_shader = LoadShader(vert_path, frag_path);
call    0 returned 20
       20:  289:    if (sim->sim_insert_program == 0 || sim->sim_collide_program == 0 || sim->render_shader.id == 0) return false;
branch  0 taken 18 (fallthrough)
branch  1 taken 2
branch  2 taken 18 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 18
        -:  290:
       18:  291:    sim->loc_vp = GetShaderLocation(sim->render_shader, "u_vp");
call    0 returned 18
        -:  292:#ifdef GPU_SIM_TESTING
       18:  293:    if (gpu_sim_fail_mode == 4) {
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2:  294:        sim->loc_vp = -1;
        -:  295:    }
        -:  296:#endif
       18:  297:    if (sim->loc_vp < 0) {
branch  0 taken 2 (fallthrough)
branch  1 taken 16
        2:  298:        sim->loc_vp = 0;
        -:  299:    }
       18:  300:    sim->loc_bounds = rlGetLocationUniform(sim->sim_collide_program, "u_bounds");
call    0 returned 18
       18:  301:    sim->loc_dt = rlGetLocationUniform(sim->sim_collide_program, "u_dt");
call    0 returned 18
       18:  302:    sim->loc_grid_dim = rlGetLocationUniform(sim->sim_collide_program, "u_grid_dim");
call    0 returned 18
       18:  303:    sim->loc_cell = rlGetLocationUniform(sim->sim_collide_program, "u_cell");
call    0 returned 18
       18:  304:    sim->loc_active_insert = glGetUniformLocation(sim->sim_insert_program, "u_active");
call    0 returned 18
       18:  305:    sim->loc_active_collide = glGetUniformLocation(sim->sim_collide_program, "u_active");
call    0 returned 18
       18:  306:    sim->loc_time = GetShaderLocation(sim->render_shader, "u_time");
call    0 returned 18
        -:  307:
       18:  308:    init_quad(sim);
call    0 returned 18
       18:  309:    if (!init_entities(sim, entity_count)) {
call    0 returned 18
branch  1 taken 2 (fallthrough)
branch  2 taken 16
        2:  310:        return false;
        -:  311:    }
       16:  312:    sim->ready = true;
       16:  313:    return true;
        -:  314:}
        -:  315:
function gpu_sim_shutdown called 16 returned 100% blocks executed 95%
       16:  316:void gpu_sim_shutdown(GpuSim *sim) {
      16*:  317:    if (!sim->ready) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 16
       16:  318:    if (sim->ssbo) glDeleteBuffers(1, &sim->ssbo);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  319:    if (sim->ssbo_head) glDeleteBuffers(1, &sim->ssbo_head);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  320:    if (sim->ssbo_next) glDeleteBuffers(1, &sim->ssbo_next);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  321:    if (sim->vbo) glDeleteBuffers(1, &sim->vbo);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  322:    if (sim->ebo) glDeleteBuffers(1, &sim->ebo);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  323:    if (sim->vao) glDeleteVertexArrays(1, &sim->vao);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  324:    if (sim->render_shader.id) UnloadShader(sim->render_shader);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  325:    if (sim->sim_insert_program) glDeleteProgram(sim->sim_insert_program);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  326:    if (sim->sim_collide_program) glDeleteProgram(sim->sim_collide_program);
branch  0 taken 16 (fallthrough)
branch  1 taken 0
call    2 returned 16
       16:  327:    memset(sim, 0, sizeof(*sim));
        -:  328:}
        -:  329:
function gpu_sim_update called 16 returned 100% blocks executed 97%
       16:  330:void gpu_sim_update(GpuSim *sim, float dt, Vector2 bounds) {
      16*:  331:    if (!sim->ready) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 16
       16:  332:    rlDrawRenderBatchActive();
call    0 returned 16
        -:  333:
       16:  334:    float cell = (bounds.x * 2.0f) / (float)GRID_W;
       16:  335:    int grid_dim[2] = {GRID_W, GRID_H};
       16:  336:    int clear = -1;
       16:  337:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, sim->ssbo_head);
call    0 returned 16
       16:  338:    glClearBufferData(GL_SHADER_STORAGE_BUFFER, GL_R32I, GL_RED_INTEGER, GL_INT, &clear);
call    0 returned 16
        -:  339:
       16:  340:    glUseProgram(sim->sim_insert_program);
call    0 returned 16
       16:  341:    int loc_bounds = rlGetLocationUniform(sim->sim_insert_program, "u_bounds");
call    0 returned 16
       16:  342:    int loc_cell = rlGetLocationUniform(sim->sim_insert_program, "u_cell");
call    0 returned 16
       16:  343:    int loc_grid = rlGetLocationUniform(sim->sim_insert_program, "u_grid_dim");
call    0 returned 16
       16:  344:    glUniform2f(loc_bounds, bounds.x, bounds.y);
call    0 returned 16
       16:  345:    glUniform1f(loc_cell, cell);
call    0 returned 16
       16:  346:    glUniform2i(loc_grid, grid_dim[0], grid_dim[1]);
call    0 returned 16
       16:  347:    if (sim->loc_active_insert >= 0) {
branch  0 taken 16 (fallthrough)
branch  1 taken 0
       16:  348:        glUniform1i(sim->loc_active_insert, sim->active_count);
call    0 returned 16
        -:  349:    }
       16:  350:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, sim->ssbo);
call    0 returned 16
       16:  351:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, sim->ssbo_head);
call    0 returned 16
       16:  352:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, sim->ssbo_next);
call    0 returned 16
        -:  353:
       16:  354:    unsigned int groups = (sim->active_count + GPU_WORKGROUP_SIZE - 1) / GPU_WORKGROUP_SIZE;
       16:  355:    if (groups > 0) {
branch  0 taken 16 (fallthrough)
branch  1 taken 0
       16:  356:        glDispatchCompute(groups, 1, 1);
call    0 returned 16
        -:  357:    }
       16:  358:    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT | GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT);
call    0 returned 16
        -:  359:
       16:  360:    glUseProgram(sim->sim_collide_program);
call    0 returned 16
       16:  361:    glUniform1f(sim->loc_dt, dt);
call    0 returned 16
       16:  362:    glUniform2f(sim->loc_bounds, bounds.x, bounds.y);
call    0 returned 16
       16:  363:    glUniform1f(sim->loc_cell, cell);
call    0 returned 16
       16:  364:    glUniform2i(sim->loc_grid_dim, grid_dim[0], grid_dim[1]);
call    0 returned 16
       16:  365:    if (sim->loc_active_collide >= 0) {
branch  0 taken 16 (fallthrough)
branch  1 taken 0
       16:  366:        glUniform1i(sim->loc_active_collide, sim->active_count);
call    0 returned 16
        -:  367:    }
       16:  368:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, sim->ssbo);
call    0 returned 16
       16:  369:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, sim->ssbo_head);
call    0 returned 16
       16:  370:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, sim->ssbo_next);
call    0 returned 16
       16:  371:    if (groups > 0) {
branch  0 taken 16 (fallthrough)
branch  1 taken 0
       16:  372:        glDispatchCompute(groups, 1, 1);
call    0 returned 16
        -:  373:    }
       16:  374:    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT | GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT);
call    0 returned 16
        -:  375:}
        -:  376:
function gpu_sim_render called 16 returned 100% blocks executed 94%
       16:  377:void gpu_sim_render(const GpuSim *sim, Camera3D camera) {
      16*:  378:    if (!sim->ready) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 16
       16:  379:    unsigned int active_fbo = rlGetActiveFramebuffer();
call    0 returned 16
       16:  380:    rlDrawRenderBatchActive();
call    0 returned 16
       16:  381:    if (active_fbo != rlGetActiveFramebuffer()) {
call    0 returned 16
branch  1 taken 0 (fallthrough)
branch  2 taken 16
    #####:  382:        rlEnableFramebuffer(active_fbo);
call    0 never executed
        -:  383:    }
       16:  384:    glViewport(0, 0, GetRenderWidth(), GetRenderHeight());
call    0 returned 16
call    1 returned 16
call    2 returned 16
        -:  385:
       16:  386:    Matrix view = GetCameraMatrix(camera);
call    0 returned 16
       16:  387:    Matrix proj = MatrixPerspective(DEG2RAD * camera.fovy,
       16:  388:                                    (float)GetRenderWidth() / (float)GetRenderHeight(),
call    0 returned 16
call    1 returned 16
call    2 returned 16
        -:  389:                                    0.1f, 200.0f);
       16:  390:    Matrix vp = MatrixMultiply(view, proj);
call    0 returned 16
        -:  391:
       16:  392:    glUseProgram(sim->render_shader.id);
call    0 returned 16
       16:  393:    glUniformMatrix4fv(sim->loc_vp, 1, GL_FALSE, MatrixToFloatV(vp).v);
call    0 returned 16
call    1 returned 16
       16:  394:    if (sim->loc_time >= 0) {
branch  0 taken 16 (fallthrough)
branch  1 taken 0
       16:  395:        glUniform1f(sim->loc_time, (float)GetTime());
call    0 returned 16
call    1 returned 16
        -:  396:    }
        -:  397:
       16:  398:    glDisable(GL_CULL_FACE);
call    0 returned 16
       16:  399:    glEnable(GL_BLEND);
call    0 returned 16
       16:  400:    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
call    0 returned 16
       16:  401:    glDisable(GL_DEPTH_TEST);
call    0 returned 16
        -:  402:
       16:  403:    glBindVertexArray(sim->vao);
call    0 returned 16
       16:  404:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sim->ebo);
call    0 returned 16
       16:  405:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, sim->ssbo);
call    0 returned 16
       16:  406:    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
call    0 returned 16
       16:  407:    glDrawElementsInstanced(GL_TRIANGLES,
       16:  408:                            sim->indices_count,
        -:  409:                            GL_UNSIGNED_SHORT,
        -:  410:                            (void *)0,
       16:  411:                            sim->active_count);
call    0 returned 16
       16:  412:    glBindVertexArray(0);
call    0 returned 16
       16:  413:    glUseProgram(0);
call    0 returned 16
        -:  414:}
        -:  415:
function gpu_sim_supported called 28 returned 100% blocks executed 89%
       28:  416:bool gpu_sim_supported(void) {
       28:  417:    GLint major = 0;
       28:  418:    GLint minor = 0;
       28:  419:    glGetIntegerv(GL_MAJOR_VERSION, &major);
call    0 returned 28
       28:  420:    glGetIntegerv(GL_MINOR_VERSION, &minor);
call    0 returned 28
      28*:  421:    return (major > 4) || (major == 4 && minor >= 6);
branch  0 taken 28 (fallthrough)
branch  1 taken 0
branch  2 taken 28 (fallthrough)
branch  3 taken 0
branch  4 taken 28 (fallthrough)
branch  5 taken 0
        -:  422:}
        -:  423:
function gpu_sim_set_active_count called 26 returned 100% blocks executed 100%
       26:  424:void gpu_sim_set_active_count(GpuSim *sim, int active_count) {
       26:  425:    if (!sim) {
branch  0 taken 2 (fallthrough)
branch  1 taken 24
        2:  426:        return;
        -:  427:    }
       24:  428:    if (active_count < 0) {
branch  0 taken 2 (fallthrough)
branch  1 taken 22
        2:  429:        active_count = 0;
        -:  430:    }
       24:  431:    if (active_count > sim->entity_count) {
branch  0 taken 2 (fallthrough)
branch  1 taken 22
        2:  432:        active_count = sim->entity_count;
        -:  433:    }
       24:  434:    sim->active_count = active_count;
        -:  435:}
