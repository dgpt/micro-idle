        -:    0:Source:/home/dgpt/code/games/micro-idle/game/gpu_sim.c
        -:    0:Graph:build/CMakeFiles/tests.dir/game/gpu_sim.c.gcno
        -:    0:Data:build/CMakeFiles/tests.dir/game/gpu_sim.c.gcda
        -:    0:Runs:1
        -:    1:#include "game/gpu_sim.h"
        -:    2:
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:#include <stdio.h>
        -:    6:#include <stdint.h>
        -:    7:
        -:    8:#include "raymath.h"
        -:    9:#include "external/glad.h"
        -:   10:#include "rlgl.h"
        -:   11:
        -:   12:#define GPU_WORKGROUP_SIZE 256
        -:   13:#define GRID_W 128
        -:   14:#define GRID_H 128
        -:   15:#define GRID_CELLS (GRID_W * GRID_H)
        -:   16:
        -:   17:typedef struct GpuEntity {
        -:   18:    float pos[4];
        -:   19:    float vel[4];
        -:   20:    float color[4];
        -:   21:    float params[4];
        -:   22:} GpuEntity;
        -:   23:
        -:   24:#ifdef GPU_SIM_TESTING
        -:   25:static int gpu_sim_fail_mode = 0;
        -:   26:
function gpu_sim_test_set_fail_mode called 7 returned 100% blocks executed 100%
        7:   27:void gpu_sim_test_set_fail_mode(int mode) {
        7:   28:    gpu_sim_fail_mode = mode;
        7:   29:}
        -:   30:#endif
        -:   31:
        -:   32:static const char *kShaderSimInsertName = "sim_insert.comp";
        -:   33:static const char *kShaderSimCollideName = "sim_collide.comp";
        -:   34:static const char *kShaderMicrobeVertName = "microbe.vert";
        -:   35:static const char *kShaderMicrobeFragName = "microbe.frag";
        -:   36:
function load_shader_source called 22 returned 100% blocks executed 75%
       22:   37:static char *load_shader_source(const char *file_name, char *resolved, size_t resolved_size) {
       22:   38:    const char *roots[] = {"data/shaders", "../data/shaders", "../../data/shaders"};
        -:   39:    char path[512];
      22*:   40:    for (size_t i = 0; i < sizeof(roots) / sizeof(roots[0]); ++i) {
branch  0 taken 22
branch  1 taken 0 (fallthrough)
       22:   41:        int written = snprintf(path, sizeof(path), "%s/%s", roots[i], file_name);
      22*:   42:        if (written <= 0 || (size_t)written >= sizeof(path)) continue;
branch  0 taken 22 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 22
       22:   43:        char *text = LoadFileText(path);
call    0 returned 22
       22:   44:        if (text) {
branch  0 taken 22 (fallthrough)
branch  1 taken 0
       22:   45:            if (resolved && resolved_size > 0) {
branch  0 taken 22 (fallthrough)
branch  1 taken 0
branch  2 taken 22 (fallthrough)
branch  3 taken 0
       22:   46:                snprintf(resolved, resolved_size, "%s", path);
        -:   47:            }
       22:   48:            return text;
        -:   49:        }
        -:   50:    }
    #####:   51:    fprintf(stderr, "failed to load shader file: %s\n", file_name);
call    0 never executed
    #####:   52:    return NULL;
        -:   53:}
        -:   54:
function resolve_shader_path called 20 returned 100% blocks executed 75%
       20:   55:static bool resolve_shader_path(const char *file_name, char *resolved, size_t resolved_size) {
       20:   56:    const char *roots[] = {"data/shaders", "../data/shaders", "../../data/shaders"};
        -:   57:    char path[512];
      20*:   58:    for (size_t i = 0; i < sizeof(roots) / sizeof(roots[0]); ++i) {
branch  0 taken 20
branch  1 taken 0 (fallthrough)
       20:   59:        int written = snprintf(path, sizeof(path), "%s/%s", roots[i], file_name);
      20*:   60:        if (written <= 0 || (size_t)written >= sizeof(path)) continue;
branch  0 taken 20 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 20
       20:   61:        if (FileExists(path)) {
call    0 returned 20
branch  1 taken 20 (fallthrough)
branch  2 taken 0
       20:   62:            if (resolved && resolved_size > 0) {
branch  0 taken 20 (fallthrough)
branch  1 taken 0
branch  2 taken 20 (fallthrough)
branch  3 taken 0
       20:   63:                snprintf(resolved, resolved_size, "%s", path);
        -:   64:            }
       20:   65:            return true;
        -:   66:        }
        -:   67:    }
    #####:   68:    fprintf(stderr, "shader path not found: %s\n", file_name);
call    0 never executed
    #####:   69:    return false;
        -:   70:}
        -:   71:
function compile_shader_from_file called 22 returned 100% blocks executed 78%
       22:   72:static unsigned int compile_shader_from_file(GLenum type, const char *file_name) {
       22:   73:    char resolved[512] = {0};
       22:   74:    bool from_file = true;
       22:   75:    char *source = load_shader_source(file_name, resolved, sizeof(resolved));
call    0 returned 22
        -:   76:#ifdef GPU_SIM_TESTING
       22:   77:    if (gpu_sim_fail_mode == 1) {
branch  0 taken 2 (fallthrough)
branch  1 taken 20
        2:   78:        if (source) UnloadFileText(source);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
call    2 returned 2
        2:   79:        source = strdup("invalid shader");
        2:   80:        from_file = false;
        -:   81:    }
        -:   82:#endif
       22:   83:    if (!source) {
branch  0 taken 0 (fallthrough)
branch  1 taken 22
    #####:   84:        return 0;
        -:   85:    }
       22:   86:    unsigned int shader = glCreateShader(type);
call    0 returned 22
       22:   87:    if (!shader) {
branch  0 taken 0 (fallthrough)
branch  1 taken 22
    #####:   88:        if (from_file) UnloadFileText(source); else free(source);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   89:        return 0;
        -:   90:    }
       22:   91:    const char *src_ptr = source;
       22:   92:    glShaderSource(shader, 1, &src_ptr, NULL);
call    0 returned 22
       22:   93:    glCompileShader(shader);
call    0 returned 22
       22:   94:    GLint compiled = 0;
       22:   95:    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
call    0 returned 22
       22:   96:    if (!compiled) {
branch  0 taken 2 (fallthrough)
branch  1 taken 20
        2:   97:        GLint length = 0;
        2:   98:        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &length);
call    0 returned 2
        2:   99:        if (length > 1) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  100:            char *log = (char *)malloc((size_t)length);
        2:  101:            if (log) {
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        2:  102:                glGetShaderInfoLog(shader, length, NULL, log);
call    0 returned 2
       2*:  103:                fprintf(stderr, "shader compile failed (%s): %s\n", resolved[0] ? resolved : file_name, log);
branch  0 taken 2 (fallthrough)
branch  1 taken 0
call    2 returned 2
        2:  104:                free(log);
        -:  105:            }
        -:  106:        }
        2:  107:        glDeleteShader(shader);
call    0 returned 2
       2*:  108:        if (from_file) UnloadFileText(source); else free(source);
branch  0 taken 0 (fallthrough)
branch  1 taken 2
call    2 never executed
        2:  109:        return 0;
        -:  110:    }
      20*:  111:    if (from_file) UnloadFileText(source); else free(source);
branch  0 taken 20 (fallthrough)
branch  1 taken 0
call    2 returned 20
       20:  112:    return shader;
        -:  113:}
        -:  114:
        -:  115:
function link_program called 20 returned 100% blocks executed 76%
       20:  116:static unsigned int link_program(unsigned int shader) {
       20:  117:    unsigned int program = glCreateProgram();
call    0 returned 20
       20:  118:    if (!program) {
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####:  119:        return 0;
        -:  120:    }
       20:  121:    if (shader) {
branch  0 taken 20 (fallthrough)
branch  1 taken 0
       20:  122:        glAttachShader(program, shader);
call    0 returned 20
        -:  123:    }
       20:  124:    glLinkProgram(program);
call    0 returned 20
       20:  125:    GLint linked = 0;
       20:  126:    glGetProgramiv(program, GL_LINK_STATUS, &linked);
call    0 returned 20
        -:  127:#ifdef GPU_SIM_TESTING
       20:  128:    if (gpu_sim_fail_mode == 2) {
branch  0 taken 2 (fallthrough)
branch  1 taken 18
        2:  129:        linked = 0;
        -:  130:    }
        -:  131:#endif
       20:  132:    if (!linked) {
branch  0 taken 2 (fallthrough)
branch  1 taken 18
        2:  133:        GLint length = 0;
        2:  134:        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &length);
call    0 returned 2
        2:  135:        if (length > 1) {
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:  136:            char *log = (char *)malloc((size_t)length);
    #####:  137:            if (log) {
branch  0 never executed
branch  1 never executed
    #####:  138:                glGetProgramInfoLog(program, length, NULL, log);
call    0 never executed
    #####:  139:                fprintf(stderr, "program link failed: %s\n", log);
call    0 never executed
    #####:  140:                free(log);
        -:  141:            }
        -:  142:        }
        2:  143:        glDeleteProgram(program);
call    0 returned 2
        2:  144:        return 0;
        -:  145:    }
       18:  146:    return program;
        -:  147:}
        -:  148:
function init_quad called 9 returned 100% blocks executed 100%
        9:  149:static void init_quad(GpuSim *sim) {
        9:  150:    float verts[] = {
        -:  151:        -0.5f, 0.0f, -0.5f,
        -:  152:         0.5f, 0.0f, -0.5f,
        -:  153:         0.5f, 0.0f,  0.5f,
        -:  154:        -0.5f, 0.0f,  0.5f
        -:  155:    };
        9:  156:    unsigned short indices[] = {0, 1, 2, 2, 3, 0};
        -:  157:
        9:  158:    glGenVertexArrays(1, &sim->vao);
call    0 returned 9
        9:  159:    glBindVertexArray(sim->vao);
call    0 returned 9
        -:  160:
        9:  161:    glGenBuffers(1, &sim->vbo);
call    0 returned 9
        9:  162:    glBindBuffer(GL_ARRAY_BUFFER, sim->vbo);
call    0 returned 9
        9:  163:    glBufferData(GL_ARRAY_BUFFER, sizeof(verts), verts, GL_STATIC_DRAW);
call    0 returned 9
        -:  164:
        9:  165:    glGenBuffers(1, &sim->ebo);
call    0 returned 9
        9:  166:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sim->ebo);
call    0 returned 9
        9:  167:    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
call    0 returned 9
        -:  168:
        9:  169:    glEnableVertexAttribArray(0);
call    0 returned 9
        9:  170:    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *)0);
call    0 returned 9
        -:  171:
        9:  172:    glBindVertexArray(0);
call    0 returned 9
        -:  173:
        9:  174:    sim->indices_count = 6;
        9:  175:}
        -:  176:
function init_entities called 9 returned 100% blocks executed 100%
        9:  177:static bool init_entities(GpuSim *sim, int count) {
        9:  178:    GpuEntity *entities = NULL;
        -:  179:#ifdef GPU_SIM_TESTING
        9:  180:    if (gpu_sim_fail_mode != 3) {
branch  0 taken 8 (fallthrough)
branch  1 taken 1
        8:  181:        entities = (GpuEntity *)malloc(sizeof(GpuEntity) * (size_t)count);
        -:  182:    }
        -:  183:#else
        -:  184:    entities = (GpuEntity *)malloc(sizeof(GpuEntity) * (size_t)count);
        -:  185:#endif
        9:  186:    if (!entities) {
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  187:        return false;
        -:  188:    }
        -:  189:
  1041046:  190:    for (int i = 0; i < count; ++i) {
branch  0 taken 1041038
branch  1 taken 8 (fallthrough)
  1041038:  191:        uint32_t seed = (uint32_t)(i + 1) * 2654435761u;
  1041038:  192:        seed ^= seed >> 16;
  1041038:  193:        float r1 = (float)(seed & 0xFFFFu) / 65535.0f;
  1041038:  194:        seed = seed * 2246822519u + 3266489917u;
  1041038:  195:        float r2 = (float)(seed & 0xFFFFu) / 65535.0f;
  1041038:  196:        seed = seed * 3266489917u + 668265263u;
  1041038:  197:        float r3 = (float)(seed & 0xFFFFu) / 65535.0f;
  1041038:  198:        int type = (int)(seed % 4u);
  1041038:  199:        float px = ((float)(i % 1000) / 1000.0f - 0.5f) * 24.0f;
  1041038:  200:        float pz = ((float)(i / 1000) / 1000.0f - 0.5f) * 20.0f;
  1041038:  201:        entities[i].pos[0] = px;
  1041038:  202:        entities[i].pos[1] = 0.0f;
  1041038:  203:        entities[i].pos[2] = pz;
  1041038:  204:        entities[i].pos[3] = 1.0f;
  1041038:  205:        entities[i].vel[0] = (r1 - 0.5f) * 0.3f;
  1041038:  206:        entities[i].vel[1] = 0.0f;
  1041038:  207:        entities[i].vel[2] = (r2 - 0.5f) * 0.3f;
  1041038:  208:        entities[i].vel[3] = 0.0f;
  1041038:  209:        switch (type) {
branch  0 taken 260261
branch  1 taken 260253
branch  2 taken 260263
branch  3 taken 260261
   260261:  210:            case 0:
   260261:  211:                entities[i].color[0] = 0.26f;
   260261:  212:                entities[i].color[1] = 0.76f;
   260261:  213:                entities[i].color[2] = 0.36f;
   260261:  214:                break;
   260253:  215:            case 1:
   260253:  216:                entities[i].color[0] = 0.18f;
   260253:  217:                entities[i].color[1] = 0.56f;
   260253:  218:                entities[i].color[2] = 0.78f;
   260253:  219:                break;
   260263:  220:            case 2:
   260263:  221:                entities[i].color[0] = 0.96f;
   260263:  222:                entities[i].color[1] = 0.72f;
   260263:  223:                entities[i].color[2] = 0.18f;
   260263:  224:                break;
   260261:  225:            default:
   260261:  226:                entities[i].color[0] = 0.78f;
   260261:  227:                entities[i].color[1] = 0.28f;
   260261:  228:                entities[i].color[2] = 0.76f;
   260261:  229:                break;
        -:  230:        }
  1041038:  231:        entities[i].color[0] += (r3 - 0.5f) * 0.12f;
  1041038:  232:        entities[i].color[1] += (r1 - 0.5f) * 0.12f;
  1041038:  233:        entities[i].color[2] += (r2 - 0.5f) * 0.12f;
  1041038:  234:        entities[i].color[3] = 0.55f;
  1041038:  235:        entities[i].params[0] = 0.9f + r3 * 1.25f;
  1041038:  236:        entities[i].params[1] = 0.0f;
  1041038:  237:        entities[i].params[2] = (float)type;
  1041038:  238:        entities[i].params[3] = r2;
        -:  239:    }
        -:  240:
        8:  241:    glGenBuffers(1, &sim->ssbo);
call    0 returned 8
        8:  242:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, sim->ssbo);
call    0 returned 8
        8:  243:    glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(GpuEntity) * (size_t)count, entities, GL_DYNAMIC_DRAW);
call    0 returned 8
        8:  244:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, sim->ssbo);
call    0 returned 8
        8:  245:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
call    0 returned 8
        -:  246:
        8:  247:    glGenBuffers(1, &sim->ssbo_head);
call    0 returned 8
        8:  248:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, sim->ssbo_head);
call    0 returned 8
        8:  249:    glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(int) * GRID_CELLS, NULL, GL_DYNAMIC_DRAW);
call    0 returned 8
        8:  250:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, sim->ssbo_head);
call    0 returned 8
        -:  251:
        8:  252:    glGenBuffers(1, &sim->ssbo_next);
call    0 returned 8
        8:  253:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, sim->ssbo_next);
call    0 returned 8
        8:  254:    glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(int) * (size_t)count, NULL, GL_DYNAMIC_DRAW);
call    0 returned 8
        8:  255:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, sim->ssbo_next);
call    0 returned 8
        8:  256:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
call    0 returned 8
        -:  257:
        8:  258:    free(entities);
        8:  259:    return true;
        -:  260:}
        -:  261:
function validate_gpu_sim_limits called 13 returned 100% blocks executed 88%
       13:  262:static bool validate_gpu_sim_limits(int count) {
       13:  263:    GLint max_storage = 0;
       13:  264:    GLint max_ssbo = 0;
       13:  265:    glGetIntegerv(GL_MAX_SHADER_STORAGE_BLOCK_SIZE, &max_storage);
call    0 returned 13
       13:  266:    glGetIntegerv(GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS, &max_ssbo);
call    0 returned 13
       13:  267:    if (max_storage <= 0 || max_ssbo < 3) {
branch  0 taken 13 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 13
    #####:  268:        return false;
        -:  269:    }
       13:  270:    size_t bytes = sizeof(GpuEntity) * (size_t)count;
       13:  271:    return bytes <= (size_t)max_storage;
        -:  272:}
        -:  273:
function gpu_sim_init called 13 returned 100% blocks executed 91%
       13:  274:bool gpu_sim_init(GpuSim *sim, int entity_count) {
       13:  275:    memset(sim, 0, sizeof(*sim));
       13:  276:    sim->entity_count = entity_count;
       13:  277:    sim->active_count = entity_count;
        -:  278:
       13:  279:    if (!gpu_sim_supported()) {
call    0 returned 13
branch  1 taken 0 (fallthrough)
branch  2 taken 13
    #####:  280:        return false;
        -:  281:    }
       13:  282:    if (!validate_gpu_sim_limits(entity_count)) {
call    0 returned 13
branch  1 taken 1 (fallthrough)
branch  2 taken 12
        1:  283:        return false;
        -:  284:    }
        -:  285:
       12:  286:    unsigned int cs_insert = compile_shader_from_file(GL_COMPUTE_SHADER, kShaderSimInsertName);
call    0 returned 12
       12:  287:    if (cs_insert == 0) return false;
branch  0 taken 2 (fallthrough)
branch  1 taken 10
       10:  288:    sim->sim_insert_program = link_program(cs_insert);
call    0 returned 10
       10:  289:    glDeleteShader(cs_insert);
call    0 returned 10
        -:  290:
       10:  291:    unsigned int cs_collide = compile_shader_from_file(GL_COMPUTE_SHADER, kShaderSimCollideName);
call    0 returned 10
      10*:  292:    if (cs_collide == 0) return false;
branch  0 taken 0 (fallthrough)
branch  1 taken 10
       10:  293:    sim->sim_collide_program = link_program(cs_collide);
call    0 returned 10
       10:  294:    glDeleteShader(cs_collide);
call    0 returned 10
        -:  295:
       10:  296:    char vert_path[512] = {0};
       10:  297:    char frag_path[512] = {0};
      10*:  298:    if (!resolve_shader_path(kShaderMicrobeVertName, vert_path, sizeof(vert_path))) return false;
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
      10*:  299:    if (!resolve_shader_path(kShaderMicrobeFragName, frag_path, sizeof(frag_path))) return false;
call    0 returned 10
branch  1 taken 0 (fallthrough)
branch  2 taken 10
       10:  300:    sim->render_shader = LoadShader(vert_path, frag_path);
call    0 returned 10
       10:  301:    if (sim->sim_insert_program == 0 || sim->sim_collide_program == 0 || sim->render_shader.id == 0) return false;
branch  0 taken 9 (fallthrough)
branch  1 taken 1
branch  2 taken 9 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 9
        -:  302:
        9:  303:    sim->loc_vp = GetShaderLocation(sim->render_shader, "u_vp");
call    0 returned 9
        -:  304:#ifdef GPU_SIM_TESTING
        9:  305:    if (gpu_sim_fail_mode == 4) {
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  306:        sim->loc_vp = -1;
        -:  307:    }
        -:  308:#endif
        9:  309:    if (sim->loc_vp < 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 8
        1:  310:        sim->loc_vp = 0;
        -:  311:    }
        9:  312:    sim->loc_bounds = rlGetLocationUniform(sim->sim_collide_program, "u_bounds");
call    0 returned 9
        9:  313:    sim->loc_dt = rlGetLocationUniform(sim->sim_collide_program, "u_dt");
call    0 returned 9
        9:  314:    sim->loc_grid_dim = rlGetLocationUniform(sim->sim_collide_program, "u_grid_dim");
call    0 returned 9
        9:  315:    sim->loc_cell = rlGetLocationUniform(sim->sim_collide_program, "u_cell");
call    0 returned 9
        9:  316:    sim->loc_active_insert = glGetUniformLocation(sim->sim_insert_program, "u_active");
call    0 returned 9
        9:  317:    sim->loc_active_collide = glGetUniformLocation(sim->sim_collide_program, "u_active");
call    0 returned 9
        9:  318:    sim->loc_time = GetShaderLocation(sim->render_shader, "u_time");
call    0 returned 9
        -:  319:
        9:  320:    init_quad(sim);
call    0 returned 9
        9:  321:    if (!init_entities(sim, entity_count)) {
call    0 returned 9
branch  1 taken 1 (fallthrough)
branch  2 taken 8
        1:  322:        return false;
        -:  323:    }
        8:  324:    sim->ready = true;
        8:  325:    return true;
        -:  326:}
        -:  327:
function gpu_sim_shutdown called 8 returned 100% blocks executed 95%
        8:  328:void gpu_sim_shutdown(GpuSim *sim) {
       8*:  329:    if (!sim->ready) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 8
        8:  330:    if (sim->ssbo) glDeleteBuffers(1, &sim->ssbo);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  331:    if (sim->ssbo_head) glDeleteBuffers(1, &sim->ssbo_head);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  332:    if (sim->ssbo_next) glDeleteBuffers(1, &sim->ssbo_next);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  333:    if (sim->vbo) glDeleteBuffers(1, &sim->vbo);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  334:    if (sim->ebo) glDeleteBuffers(1, &sim->ebo);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  335:    if (sim->vao) glDeleteVertexArrays(1, &sim->vao);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  336:    if (sim->render_shader.id) UnloadShader(sim->render_shader);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  337:    if (sim->sim_insert_program) glDeleteProgram(sim->sim_insert_program);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  338:    if (sim->sim_collide_program) glDeleteProgram(sim->sim_collide_program);
branch  0 taken 8 (fallthrough)
branch  1 taken 0
call    2 returned 8
        8:  339:    memset(sim, 0, sizeof(*sim));
        -:  340:}
        -:  341:
function gpu_sim_update called 8 returned 100% blocks executed 97%
        8:  342:void gpu_sim_update(GpuSim *sim, float dt, Vector2 bounds) {
       8*:  343:    if (!sim->ready) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 8
        8:  344:    rlDrawRenderBatchActive();
call    0 returned 8
        -:  345:
        8:  346:    float cell = (bounds.x * 2.0f) / (float)GRID_W;
        8:  347:    int grid_dim[2] = {GRID_W, GRID_H};
        8:  348:    int clear = -1;
        8:  349:    glBindBuffer(GL_SHADER_STORAGE_BUFFER, sim->ssbo_head);
call    0 returned 8
        8:  350:    glClearBufferData(GL_SHADER_STORAGE_BUFFER, GL_R32I, GL_RED_INTEGER, GL_INT, &clear);
call    0 returned 8
        -:  351:
        8:  352:    glUseProgram(sim->sim_insert_program);
call    0 returned 8
        8:  353:    int loc_bounds = rlGetLocationUniform(sim->sim_insert_program, "u_bounds");
call    0 returned 8
        8:  354:    int loc_cell = rlGetLocationUniform(sim->sim_insert_program, "u_cell");
call    0 returned 8
        8:  355:    int loc_grid = rlGetLocationUniform(sim->sim_insert_program, "u_grid_dim");
call    0 returned 8
        8:  356:    glUniform2f(loc_bounds, bounds.x, bounds.y);
call    0 returned 8
        8:  357:    glUniform1f(loc_cell, cell);
call    0 returned 8
        8:  358:    glUniform2i(loc_grid, grid_dim[0], grid_dim[1]);
call    0 returned 8
        8:  359:    if (sim->loc_active_insert >= 0) {
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:  360:        glUniform1i(sim->loc_active_insert, sim->active_count);
call    0 returned 8
        -:  361:    }
        8:  362:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, sim->ssbo);
call    0 returned 8
        8:  363:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, sim->ssbo_head);
call    0 returned 8
        8:  364:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, sim->ssbo_next);
call    0 returned 8
        -:  365:
        8:  366:    unsigned int groups = (sim->active_count + GPU_WORKGROUP_SIZE - 1) / GPU_WORKGROUP_SIZE;
        8:  367:    if (groups > 0) {
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:  368:        glDispatchCompute(groups, 1, 1);
call    0 returned 8
        -:  369:    }
        8:  370:    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT | GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT);
call    0 returned 8
        -:  371:
        8:  372:    glUseProgram(sim->sim_collide_program);
call    0 returned 8
        8:  373:    glUniform1f(sim->loc_dt, dt);
call    0 returned 8
        8:  374:    glUniform2f(sim->loc_bounds, bounds.x, bounds.y);
call    0 returned 8
        8:  375:    glUniform1f(sim->loc_cell, cell);
call    0 returned 8
        8:  376:    glUniform2i(sim->loc_grid_dim, grid_dim[0], grid_dim[1]);
call    0 returned 8
        8:  377:    if (sim->loc_active_collide >= 0) {
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:  378:        glUniform1i(sim->loc_active_collide, sim->active_count);
call    0 returned 8
        -:  379:    }
        8:  380:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, sim->ssbo);
call    0 returned 8
        8:  381:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, sim->ssbo_head);
call    0 returned 8
        8:  382:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, sim->ssbo_next);
call    0 returned 8
        8:  383:    if (groups > 0) {
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:  384:        glDispatchCompute(groups, 1, 1);
call    0 returned 8
        -:  385:    }
        8:  386:    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT | GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT);
call    0 returned 8
        -:  387:}
        -:  388:
function gpu_sim_render called 8 returned 100% blocks executed 94%
        8:  389:void gpu_sim_render(const GpuSim *sim, Camera3D camera) {
       8*:  390:    if (!sim->ready) return;
branch  0 taken 0 (fallthrough)
branch  1 taken 8
        8:  391:    unsigned int active_fbo = rlGetActiveFramebuffer();
call    0 returned 8
        8:  392:    rlDrawRenderBatchActive();
call    0 returned 8
        8:  393:    if (active_fbo != rlGetActiveFramebuffer()) {
call    0 returned 8
branch  1 taken 0 (fallthrough)
branch  2 taken 8
    #####:  394:        rlEnableFramebuffer(active_fbo);
call    0 never executed
        -:  395:    }
        8:  396:    glViewport(0, 0, GetRenderWidth(), GetRenderHeight());
call    0 returned 8
call    1 returned 8
call    2 returned 8
        -:  397:
        8:  398:    Matrix view = GetCameraMatrix(camera);
call    0 returned 8
        8:  399:    Matrix proj = MatrixPerspective(DEG2RAD * camera.fovy,
        8:  400:                                    (float)GetRenderWidth() / (float)GetRenderHeight(),
call    0 returned 8
call    1 returned 8
call    2 returned 8
        -:  401:                                    0.1f, 200.0f);
        8:  402:    Matrix vp = MatrixMultiply(view, proj);
call    0 returned 8
        -:  403:
        8:  404:    glUseProgram(sim->render_shader.id);
call    0 returned 8
        8:  405:    glUniformMatrix4fv(sim->loc_vp, 1, GL_FALSE, MatrixToFloatV(vp).v);
call    0 returned 8
call    1 returned 8
        8:  406:    if (sim->loc_time >= 0) {
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        8:  407:        glUniform1f(sim->loc_time, (float)GetTime());
call    0 returned 8
call    1 returned 8
        -:  408:    }
        -:  409:
        8:  410:    glDisable(GL_CULL_FACE);
call    0 returned 8
        8:  411:    glEnable(GL_BLEND);
call    0 returned 8
        8:  412:    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
call    0 returned 8
        8:  413:    glDisable(GL_DEPTH_TEST);
call    0 returned 8
        -:  414:
        8:  415:    glBindVertexArray(sim->vao);
call    0 returned 8
        8:  416:    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sim->ebo);
call    0 returned 8
        8:  417:    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, sim->ssbo);
call    0 returned 8
        8:  418:    glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
call    0 returned 8
        8:  419:    glDrawElementsInstanced(GL_TRIANGLES,
        8:  420:                            sim->indices_count,
        -:  421:                            GL_UNSIGNED_SHORT,
        -:  422:                            (void *)0,
        8:  423:                            sim->active_count);
call    0 returned 8
        8:  424:    glBindVertexArray(0);
call    0 returned 8
        8:  425:    glUseProgram(0);
call    0 returned 8
        -:  426:}
        -:  427:
function gpu_sim_supported called 14 returned 100% blocks executed 89%
       14:  428:bool gpu_sim_supported(void) {
       14:  429:    GLint major = 0;
       14:  430:    GLint minor = 0;
       14:  431:    glGetIntegerv(GL_MAJOR_VERSION, &major);
call    0 returned 14
       14:  432:    glGetIntegerv(GL_MINOR_VERSION, &minor);
call    0 returned 14
      14*:  433:    return (major > 4) || (major == 4 && minor >= 6);
branch  0 taken 14 (fallthrough)
branch  1 taken 0
branch  2 taken 14 (fallthrough)
branch  3 taken 0
branch  4 taken 14 (fallthrough)
branch  5 taken 0
        -:  434:}
        -:  435:
function gpu_sim_set_active_count called 13 returned 100% blocks executed 100%
       13:  436:void gpu_sim_set_active_count(GpuSim *sim, int active_count) {
       13:  437:    if (!sim) {
branch  0 taken 1 (fallthrough)
branch  1 taken 12
        1:  438:        return;
        -:  439:    }
       12:  440:    if (active_count < 0) {
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        1:  441:        active_count = 0;
        -:  442:    }
       12:  443:    if (active_count > sim->entity_count) {
branch  0 taken 1 (fallthrough)
branch  1 taken 11
        1:  444:        active_count = sim->entity_count;
        -:  445:    }
       12:  446:    sim->active_count = active_count;
        -:  447:}
