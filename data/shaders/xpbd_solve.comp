#version 430 core

// XPBD Step 2: Solve constraints (per-microbe sequential)
// Pure functional approach: each thread handles ONE microbe's constraints sequentially
// This eliminates race conditions while maintaining reasonable performance

layout(local_size_x = 64) in;

struct Particle {
    vec4 pos;       // xyz position, w = inverse mass
    vec4 pos_prev;  // previous position
    vec4 vel;       // xyz velocity, w = microbe_id
    vec4 data;      // x = particle_index, y = constraint_start, z = constraint_count
};

struct Constraint {
    int p1;              // particle index 1
    int p2;              // particle index 2
    float rest_length;   // target distance
    float compliance;    // alpha (inverse stiffness)
    float lambda;        // accumulated Lagrange multiplier
    float padding[3];
};

layout(std430, binding = 0) buffer Particles { Particle particles[]; };
layout(std430, binding = 1) buffer Constraints { Constraint constraints[]; };

uniform float u_dt;
uniform int u_microbe_count;
uniform int u_constraints_per_microbe;

void main() {
    uint microbe_id = gl_GlobalInvocationID.x;
    if (microbe_id >= uint(u_microbe_count)) return;

    // Process ALL constraints for this microbe sequentially
    int constraint_start = int(microbe_id) * u_constraints_per_microbe;

    for (int i = 0; i < u_constraints_per_microbe; i++) {
        int idx = constraint_start + i;
        Constraint c = constraints[idx];

    // Get particle positions and inverse masses
    vec3 x1 = particles[c.p1].pos.xyz;
    vec3 x2 = particles[c.p2].pos.xyz;
    float w1 = particles[c.p1].pos.w;  // inverse mass
    float w2 = particles[c.p2].pos.w;

    // Skip if both particles are fixed
    if (w1 < 0.0001 && w2 < 0.0001) return;

    // Compute constraint: C = |x1 - x2| - rest_length
    vec3 delta = x1 - x2;
    float dist = length(delta);

    // Avoid division by zero
    if (dist < 0.0001) return;

    float C = dist - c.rest_length;

    // Gradient of constraint (normalized direction)
    vec3 gradC = delta / dist;

    // Compliance parameter: α̃ = α / dt²
    float alpha_tilde = c.compliance / (u_dt * u_dt);

    // Denominator: w1|∇C|² + w2|∇C|² + α̃
    // Since |gradC| = 1 for distance constraints: K = w1 + w2 + α̃
    float K = w1 + w2 + alpha_tilde;

    if (K < 0.0001) return;

    // Compute Lagrange multiplier change
    // Δλ = -(C + α̃λ) / K
    float delta_lambda = -(C + alpha_tilde * c.lambda) / K;

    // Update accumulated multiplier
    constraints[idx].lambda = c.lambda + delta_lambda;

    // Apply position corrections
    // Δx1 = +w1 * Δλ * ∇C
    // Δx2 = -w2 * Δλ * ∇C
    vec3 correction = delta_lambda * gradC;

        // Apply position corrections (safe within single microbe)
        // Pure Gauss-Seidel: sequential updates within microbe, parallel across microbes
        if (w1 > 0.0001) {
            particles[c.p1].pos.xyz += w1 * correction;
        }
        if (w2 > 0.0001) {
            particles[c.p2].pos.xyz -= w2 * correction;
        }
    }  // end constraint loop
}
