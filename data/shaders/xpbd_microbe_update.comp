#version 430 core

// Update microbe metadata from particle positions
// Computes center of mass, squish amount, and bounding box.

layout(local_size_x = 64) in;

struct Particle {
    vec4 pos;       // xyz position, w = inverse mass
    vec4 pos_prev;  // previous position
    vec4 vel;       // xyz velocity, w = microbe_id
    vec4 data;      // x = particle_index, y = constraint_start, z = constraint_count
};

struct Microbe {
    vec4 center;    // xyz center of mass, w = radius
    vec4 color;     // rgba
    vec4 params;    // x = type, y = base_stiffness, z = seed, w = squish_amount
    vec4 aabb;      // bounding box (min_x, min_z, max_x, max_z)
};

struct Constraint {
    int p1;
    int p2;
    float rest_length;
    float compliance;
    float lambda;
    float padding[3];
};

layout(std430, binding = 0) readonly buffer Particles { Particle particles[]; };
layout(std430, binding = 1) readonly buffer Constraints { Constraint constraints[]; };
layout(std430, binding = 2) buffer Microbes { Microbe microbes[]; };

uniform int u_microbe_count;
uniform int u_particles_per_microbe;
uniform int u_constraints_per_microbe;

void main() {
    uint microbe_id = gl_GlobalInvocationID.x;
    if (microbe_id >= uint(u_microbe_count)) return;

    int particle_start = int(microbe_id) * u_particles_per_microbe;

    // Compute center of mass
    vec3 center = vec3(0.0);
    vec3 min_pos = vec3(1e10);
    vec3 max_pos = vec3(-1e10);

    for (int i = 0; i < u_particles_per_microbe; i++) {
        vec3 p = particles[particle_start + i].pos.xyz;
        center += p;
        min_pos = min(min_pos, p);
        max_pos = max(max_pos, p);
    }
    center /= float(u_particles_per_microbe);

    // Compute average radius (for rendering scale)
    float avg_radius = 0.0;
    for (int i = 0; i < u_particles_per_microbe; i++) {
        vec3 p = particles[particle_start + i].pos.xyz;
        avg_radius += length(p - center);
    }
    avg_radius /= float(u_particles_per_microbe);

    // Compute squish amount from constraint stretch
    // Squish = how much constraints deviate from rest length
    int constraint_start = int(microbe_id) * u_constraints_per_microbe;
    float total_stretch = 0.0;
    float max_compression = 0.0;

    for (int i = 0; i < u_constraints_per_microbe; i++) {
        Constraint c = constraints[constraint_start + i];
        vec3 x1 = particles[c.p1].pos.xyz;
        vec3 x2 = particles[c.p2].pos.xyz;
        float current_len = length(x1 - x2);
        float stretch = (c.rest_length - current_len) / c.rest_length;
        total_stretch += abs(stretch);
        if (stretch > 0.0) {
            max_compression = max(max_compression, stretch);
        }
    }

    float avg_stretch = total_stretch / float(u_constraints_per_microbe);

    // Squish is based on compression (positive = squished)
    // Smooth it for visual stability
    float current_squish = microbes[microbe_id].params.w;
    float target_squish = clamp(max_compression * 3.0, 0.0, 1.0);
    float squish = mix(current_squish, target_squish, 0.3);  // Smooth interpolation

    // Update microbe data
    microbes[microbe_id].center = vec4(center, avg_radius);
    microbes[microbe_id].aabb = vec4(min_pos.x, min_pos.z, max_pos.x, max_pos.z);
    microbes[microbe_id].params.w = squish;
}
