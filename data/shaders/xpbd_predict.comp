#version 430 core

// XPBD Predict Step - EXCITABLE CORTEX MODEL
// Based on research: Pseudopods form as discrete excitable bursts
// with global inhibition (only one pseudopod active at a time)
// Reference: https://pmc.ncbi.nlm.nih.gov/articles/PMC3310873/

layout(local_size_x = 256) in;

struct Particle {
    vec4 pos;       // xyz position, w = inverse mass
    vec4 pos_prev;  // previous position
    vec4 vel;       // xyz velocity, w = microbe_id
    vec4 data;      // x = particle_index, y = constraint_start, z = constraint_count
};

struct Microbe {
    vec4 center;    // xyz center of mass, w = radius
    vec4 color;     // rgba
    vec4 params;    // x = type, y = stiffness, z = seed, w = squish_amount
    vec4 aabb;      // bounding box
};

layout(std430, binding = 0) buffer Particles { Particle particles[]; };
layout(std430, binding = 1) buffer Microbes { Microbe microbes[]; };

uniform float u_dt;
uniform int u_particle_count;
uniform int u_particles_per_microbe;
uniform float u_time;
uniform vec2 u_cursor;
uniform vec2 u_bounds;  // World space bounds (half-width, half-height)

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uint(u_particle_count)) return;

    Particle p = particles[idx];
    float inv_mass = p.pos.w;
    if (inv_mass < 0.0001) return;

    p.pos_prev.xyz = p.pos.xyz;

    int microbe_id = int(p.vel.w);
    int particle_idx = int(p.data.x);
    Microbe m = microbes[microbe_id];

    float seed = m.params.z;
    vec3 center = m.center.xyz;
    float base_radius = m.center.w;

    // === EXCITABLE CORTEX & MEMORY (EC&M) MODEL ===
    // Pseudopod forms as discrete excitable burst with ~10s lifetime
    // Global inhibition: only one pseudopod active at a time
    // Local memory creates zig-zag alternating pattern

    // EC&M: Pseudopod extends, searches, then retracts (like fingers exploring)
    float pseudopod_lifetime = 12.0;
    float cycle_time = mod(u_time + seed * 4.0, pseudopod_lifetime);
    float phase = cycle_time / pseudopod_lifetime;

    // Phases: extend (0-0.35), search/hold (0.35-0.75), retract (0.75-1.0)
    float extend = smoothstep(0.0, 0.35, phase);
    float retract = smoothstep(0.75, 1.0, phase);
    float burst_envelope = extend * (1.0 - retract);

    // Searching behavior: pseudopod sweeps while extended (like feeling around)
    float base_angle = seed * 6.28318;  // Each cell has unique base direction
    float zig_zag = sin(cycle_time * 0.4) * 2.6;  // Slow wide sweep (zig-zag)
    float search = sin(cycle_time * 4.0) * 0.5 * burst_envelope;  // Fast searching wiggle when active
    float active_angle = base_angle + zig_zag + search;

    // Calculate this particle's position relative to center
    vec3 to_particle = p.pos.xyz - center;
    float particle_angle = atan(to_particle.z, to_particle.x);

    // Angular distance to active pseudopod
    float angle_diff = abs(particle_angle - active_angle);
    if (angle_diff > 3.14159) angle_diff = 6.28318 - angle_diff;

    // Very narrow cone for thin finger-like pseudopod (not fat bulge)
    float cone_width = 0.25;  // ~14 degrees - thin pseudopod
    float excitation = smoothstep(cone_width, 0.0, angle_diff);

    // STRONG tip focus: only outermost particles extend (thin finger, not fat blob)
    float dist_from_center = length(to_particle.xz);
    float tip_factor = smoothstep(0.7, 1.0, dist_from_center);  // Only outer ring extends
    excitation = excitation * tip_factor * burst_envelope;

    // === AMOEBA CRAWLING: Long pseudopod pulls cell forward ===

    vec2 pseudopod_dir = vec2(cos(active_angle), sin(active_angle));

    // Controlled pseudopod extension - thin finger not fat bulge
    vec3 pseudopod_vel = vec3(0.0);
    if (excitation > 0.01) {
        vec3 radial_dir = normalize(to_particle);
        // Controlled outward force on tip particles
        pseudopod_vel = radial_dir * excitation * 3.0;
        // Directional pull creates elongated shape
        pseudopod_vel += vec3(pseudopod_dir.x, 0.0, pseudopod_dir.y) * excitation * 1.5;
    }

    // Cell body follows pseudopod slowly
    vec3 locomotion_vel = vec3(pseudopod_dir.x, 0.0, pseudopod_dir.y) * burst_envelope * 0.2;

    // Apply velocities with smooth damping
    float damping = 0.94;
    p.vel.xyz = p.vel.xyz * damping + (locomotion_vel + pseudopod_vel) * (1.0 - damping);

    // Integrate velocity to position (Verlet integration)
    p.pos.xyz = p.pos.xyz + p.vel.xyz * u_dt;

    // Let constraints handle shape - no artificial position clamping
    // XPBD distance constraints will naturally limit particle extension

    particles[idx] = p;
}
