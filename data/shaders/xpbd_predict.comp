#version 430 core

// XPBD Predict Step - EXCITABLE CORTEX MODEL
// Based on research: Pseudopods form as discrete excitable bursts
// with global inhibition (only one pseudopod active at a time)
// Reference: https://pmc.ncbi.nlm.nih.gov/articles/PMC3310873/

layout(local_size_x = 256) in;

struct Particle {
    vec4 pos;       // xyz position, w = inverse mass
    vec4 pos_prev;  // previous position
    vec4 vel;       // xyz velocity, w = microbe_id
    vec4 data;      // x = particle_index, y = constraint_start, z = constraint_count
};

struct Microbe {
    vec4 center;    // xyz center of mass, w = radius
    vec4 color;     // rgba
    vec4 params;    // x = type, y = stiffness, z = seed, w = squish_amount
    vec4 aabb;      // bounding box
};

layout(std430, binding = 0) buffer Particles { Particle particles[]; };
layout(std430, binding = 1) buffer Microbes { Microbe microbes[]; };

uniform float u_dt;
uniform int u_particle_count;
uniform int u_particles_per_microbe;
uniform float u_time;
uniform vec2 u_cursor;

float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uint(u_particle_count)) return;

    Particle p = particles[idx];
    float inv_mass = p.pos.w;
    if (inv_mass < 0.0001) return;

    p.pos_prev.xyz = p.pos.xyz;

    int microbe_id = int(p.vel.w);
    int particle_idx = int(p.data.x);
    Microbe m = microbes[microbe_id];

    float seed = m.params.z;
    vec3 center = m.center.xyz;
    float base_radius = m.center.w;

    // === EXCITABLE CORTEX MODEL - Clean Implementation ===
    // Pseudopod forms as discrete excitable burst with ~10s lifetime
    // Global inhibition: only ONE pseudopod active at a time

    // Wander direction (identical for all microbes)
    float wander_phase = u_time * 0.3;
    float wander_angle = sin(wander_phase) * 1.2 + cos(wander_phase * 0.6) * 0.7;
    vec2 desired_dir = normalize(vec2(cos(wander_angle), sin(wander_angle)));

    // Pseudopod burst timing (10 second lifetime)
    float pseudopod_lifetime = 10.0;
    float burst_phase = mod(u_time, pseudopod_lifetime) / pseudopod_lifetime;

    // Active pseudopod angle rotates smoothly with desired direction
    float active_angle = wander_angle + sin(burst_phase * 6.28318) * 0.2;

    // Calculate this particle's position relative to center
    vec3 to_particle = p.pos.xyz - center;
    float particle_angle = atan(to_particle.z, to_particle.x);

    // Angular distance to active pseudopod
    float angle_diff = abs(particle_angle - active_angle);
    if (angle_diff > 3.14159) angle_diff = 6.28318 - angle_diff;

    // Narrow cone for distinct pseudopod (~40 degrees)
    float cone_width = 0.7;
    float excitation = smoothstep(cone_width, 0.0, angle_diff);
    excitation = excitation * excitation;  // Sharper falloff

    // === VELOCITY-BASED SMOOTH MOTION ===
    // Apply forces via velocity, let constraints handle shape

    // Base locomotion velocity for all particles (realistic amoeba speed)
    vec3 locomotion_vel = vec3(desired_dir.x, 0.0, desired_dir.y) * 0.6;

    // Pseudopod particles get additional outward velocity
    vec3 pseudopod_vel = vec3(0.0);
    if (excitation > 0.01) {
        vec3 radial_dir = normalize(to_particle);
        pseudopod_vel = radial_dir * excitation * 1.0;
        pseudopod_vel += vec3(desired_dir.x, 0.0, desired_dir.y) * excitation * 0.4;
    }

    // Apply velocities smoothly (damped)
    float damping = 0.95;
    p.vel.xyz = p.vel.xyz * damping + (locomotion_vel + pseudopod_vel) * (1.0 - damping);

    // Integrate velocity to position (Verlet integration)
    p.pos.xyz = p.pos.xyz + p.vel.xyz * u_dt;

    // Velocity limit
    float max_vel = 4.0;
    float speed = length(p.vel.xyz);
    if (speed > max_vel) {
        p.vel.xyz *= max_vel / speed;
    }

    // Safety bounds to prevent runaway particles
    float max_distance = 1.5;
    float current_distance = length(p.pos.xyz - center);
    if (current_distance > max_distance) {
        p.pos.xyz = center + normalize(p.pos.xyz - center) * max_distance;
    }

    particles[idx] = p;
}
