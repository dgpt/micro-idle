#version 430 core

// XPBD Collision: Handle inter-microbe collisions
// Uses spatial grid for broad-phase, then particle-particle collision for narrow-phase.
// Collisions are resolved as temporary distance constraints.

layout(local_size_x = 256) in;

struct Particle {
    vec4 pos;       // xyz position, w = inverse mass
    vec4 pos_prev;  // previous position
    vec4 vel;       // xyz velocity, w = microbe_id
    vec4 data;      // x = particle_index, y = constraint_start, z = constraint_count
};

layout(std430, binding = 0) buffer Particles { Particle particles[]; };
layout(std430, binding = 1) buffer GridHead { int head[]; };
layout(std430, binding = 2) buffer GridNext { int next[]; };

uniform float u_dt;
uniform vec2 u_bounds;
uniform float u_cell;
uniform ivec2 u_grid_dim;
uniform int u_particle_count;
uniform float u_collision_radius;  // Minimum distance between particles

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uint(u_particle_count)) return;

    Particle p = particles[idx];
    float inv_mass = p.pos.w;
    float my_microbe = p.vel.w;

    // Skip fixed particles
    if (inv_mass < 0.0001) return;

    vec3 pos = p.pos.xyz;

    // Grid cell
    int gx = int((pos.x + u_bounds.x) / u_cell);
    int gz = int((pos.z + u_bounds.y) / u_cell);
    gx = clamp(gx, 0, u_grid_dim.x - 1);
    gz = clamp(gz, 0, u_grid_dim.y - 1);

    vec3 total_push = vec3(0.0);
    int collision_count = 0;

    // Check neighboring cells
    for (int dz = -1; dz <= 1; ++dz) {
        int nz = gz + dz;
        if (nz < 0 || nz >= u_grid_dim.y) continue;
        for (int dx = -1; dx <= 1; ++dx) {
            int nx = gx + dx;
            if (nx < 0 || nx >= u_grid_dim.x) continue;
            int cell = nz * u_grid_dim.x + nx;

            for (int j = head[cell]; j != -1; j = next[j]) {
                if (j == int(idx)) continue;

                // Skip particles from same microbe (handled by internal constraints)
                float other_microbe = particles[j].vel.w;
                if (abs(my_microbe - other_microbe) < 0.5) continue;

                vec3 other_pos = particles[j].pos.xyz;
                vec3 delta = pos - other_pos;
                float dist = length(delta);

                // Collision detected
                if (dist < u_collision_radius && dist > 0.0001) {
                    vec3 normal = delta / dist;
                    float overlap = u_collision_radius - dist;

                    // Push apart (position-based collision response)
                    // Split based on inverse masses
                    float other_inv_mass = particles[j].pos.w;
                    float total_inv_mass = inv_mass + other_inv_mass;

                    if (total_inv_mass > 0.0001) {
                        float ratio = inv_mass / total_inv_mass;
                        // Moderate push for visible squishing and deformation
                        float push_strength = 0.5;
                        total_push += normal * overlap * ratio * push_strength;

                        // Moderate velocity damping for bouncy collisions
                        vec3 relative_vel = p.vel.xyz - particles[j].vel.xyz;
                        float vel_along_normal = dot(relative_vel, normal);
                        if (vel_along_normal < 0.0) {
                            // Partially damp approaching velocities for bounce
                            p.vel.xyz -= normal * vel_along_normal * 0.4;
                        }

                        collision_count++;
                    }
                }
            }
        }
    }

    // Apply collision response
    if (collision_count > 0) {
        particles[idx].pos.xyz += total_push;
    }

    // Boundary collision
    float margin = 0.2;
    if (pos.x < -u_bounds.x + margin) {
        particles[idx].pos.x = -u_bounds.x + margin;
    }
    if (pos.x > u_bounds.x - margin) {
        particles[idx].pos.x = u_bounds.x - margin;
    }
    if (pos.z < -u_bounds.y + margin) {
        particles[idx].pos.z = -u_bounds.y + margin;
    }
    if (pos.z > u_bounds.y - margin) {
        particles[idx].pos.z = u_bounds.y - margin;
    }
}
