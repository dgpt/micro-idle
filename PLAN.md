# Micro-Idle Engine - Implementation Plan

## Current Status
- **Phase**: Critical Bug Fixes & Architectural Cleanup - Phase 1 → Phase 2 Transition
- **Last Updated**: 2025-01-27
- **Status**: Fixing critical simulation bugs and removing legacy XPBD/C code
- **Architecture**: C++20/FLECS/Jolt Physics (Phase 2) - Removing Phase 1 XPBD GPU simulation
- **Quality Gates**: Build must succeed, tests must pass, code coverage >98%

---

## Current Sprint: Physics Fixes & Legacy Code Removal

**Objective**: Fix critical simulation bugs ("Ghost Microbe" and "Locomotion Treadmill") and remove all legacy Phase 1 XPBD/C code to enforce C++20/FLECS/Jolt architecture.

### Task 1: Apply Physics & Locomotion Fixes

#### 1.1 Fix "Ghost Microbe" (Enable Gravity)
**Target**: `src/systems/PhysicsSystem.cpp` - `PhysicsSystemState` constructor
- **Change**: `physicsSystem->SetGravity(JPH::Vec3(0, 0, 0));`
- **To**: `physicsSystem->SetGravity(JPH::Vec3(0, -9.81f, 0));`
- **Status**: [x] **COMPLETED** - Gravity enabled (line 119)

#### 1.2 Fix "Locomotion Treadmill" (Tune Friction & Damping)
**Target**: `src/systems/SoftBodyFactory.cpp` - `CreateAmoeba` function
- **Set Friction**: `creationSettings.mFriction = 1.5f;` (Reduced from 8.0f/20.0f)
- **Set Damping**: `creationSettings.mLinearDamping = 0.5f;` (Increased from 0.4f/0.8f)
- **Status**: [x] **COMPLETED** - Friction set to 1.5f, damping set to 0.5f (lines 81-82)

#### 1.3 Implement "Body Pull" Locomotion
**Target**: `src/systems/ECMLocomotionSystem.cpp` - `applyRetractionForces` function
- **Action**: Replace entire function with normalized "Body Pull" implementation
- **Key Changes**:
  - Distribute force across body vertices (excluding anchored foot)
  - Normalize force by vertex count to prevent force explosions
  - Pull body toward anchored foot instead of pulling foot back
  - Function signature updated to remove unused `skeleton` parameter
- **Status**: [x] **COMPLETED** - Function replaced with normalized Body Pull implementation (lines 147-190)
- **Implementation**: Uses `RETRACT_FORCE / (vertexCount - 1.0f)` to normalize force per vertex, applies velocity impulse to all vertices except target (anchored foot)

### Task 2: Remove Legacy Code

#### 2.1 Delete Legacy XPBD Compute Shaders
**Target**: `data/shaders/xpbd_*.comp` files
- [x] `xpbd_bounds.comp` - **DELETED**
- [x] `xpbd_collide.comp` - **DELETED**
- [x] `xpbd_finalize.comp` - **DELETED**
- [x] `xpbd_grid_insert.comp` - **DELETED**
- [x] `xpbd_microbe_update.comp` - **DELETED**
- [x] `xpbd_predict.comp` - **DELETED**
- [x] `xpbd_pressure.comp` - **DELETED**
- [x] `xpbd_solve.comp` - **DELETED**
- **Status**: [x] **COMPLETED** - All 8 XPBD compute shaders removed

#### 2.2 Delete Legacy C Implementations
**Target**: Root and source directories
- [x] `gpu_sim.c` / `gpu_sim.h` (Old GPU simulation engine) - **NOT FOUND** (already removed)
- [x] `gpu_sim.c.gcov` (Coverage file) - **DELETED**
- [x] `game.c` (Replaced by `game/game.cpp`) - **NOT FOUND** (already replaced)
- [x] `engine.c` (Replaced by `engine/platform/engine.cpp`) - **NOT FOUND** (already replaced)
- [x] `main.c` (Replaced by `bin/main.cpp`) - **NOT FOUND** (already replaced)
- [x] `rng.c` (Replaced by `engine/util/rng.cpp`) - **NOT FOUND** (already replaced)
- [x] `*.spv.h` files (Old compiled shader headers) - **NOT FOUND** (none exist)
- [x] Legacy `.gcov` coverage files - **DELETED** (`engine.c.gcov`, `game.c.gcov`, `rng.c.gcov`, `time.c.gcov`)
- **Status**: [x] **COMPLETED** - All legacy C files and coverage files removed

### Task 3: Verification & Documentation

- [x] Update PLAN.md to mark "Phase 0: Refactoring - Biological Accuracy" as In Progress
- [x] Log removal of legacy XPBD modules in PLAN.md
- [x] Verify clean build after deletions - **BUILD SUCCESSFUL** (2025-01-27)
- [ ] Run tests to ensure no regressions - **REQUIRES WINDOWS** (tests.exe is Windows executable)
- [ ] Verify code coverage >98% - **REQUIRES WINDOWS** (coverage tools need Windows execution)
- [ ] Check generated test images for visual verification - **REQUIRES WINDOWS** (screenshots generated by tests.exe)

**Verification Requirements**:
- **MUST RUN TESTS AND LOOK AT IMAGES GENERATED TO VERIFY CHANGES**
- **BUILD MUST BE SUCCESSFUL** ✅ **COMPLETED** - Build succeeded with all changes
- **TESTS MUST PASS** ⚠️ **PENDING** - Requires Windows execution (tests.exe built successfully)
- **CODE COVERAGE MUST BE >98%** ⚠️ **PENDING** - Requires Windows execution

**Build Status** (2025-01-27):
- ✅ Build completed successfully: `build/game.exe` and `build/tests.exe` created
- ✅ No compilation errors
- ✅ All source files compile correctly
- ⚠️ Tests executable ready but requires Windows to run (cross-compiled from WSL)

---

## Critical Bugs Found & Solutions

### Bug #1: "Ghost Microbe" (Invisible Entities)

**Root Cause**: Zero gravity combined with repositioning logic causes microbes to float forever at Y=25.0, behind the camera at Y=22.0.

**The Trap**:
- In `PhysicsSystem.cpp`, gravity is set to `(0, 0, 0)`
- When window resizes (common on startup/OS interaction), `World::repositionMicrobesInBounds` teleports microbes to `Y = 25.0f` to "drop them from the heavens"
- Since gravity is zero, they **float forever at Y=25.0**
- Camera is at `Y=22.0` looking down
- Microbes are floating *behind* the camera, making them invisible

**Solution**: Enable gravity so microbes fall back to petri dish (`Y=0`) if they get picked up or spawned high.

**Status**: [x] **FIXED**: Changed `PhysicsSystem.cpp` line 119 from `SetGravity(JPH::Vec3(0, 0, 0))` to `SetGravity(JPH::Vec3(0, -9.81f, 0))`

---

### Bug #2: "Treadmill" Bug (No Net Movement)

**Root Cause**: Current locomotion implementation creates zero net movement because it violates Newton's laws for friction-based movement.

**The Problem**:
- **Current Logic**: Push vertex out (Extend) → Pull vertex in (Retract). The amoeba just wiggles in place.
- **Required Logic**: Push vertex out (Extend) → **Pull Body towards Vertex** (Retract).
- This simulates the cell cytoskeleton contracting to pull the heavy nucleus forward while the pseudopod tip stays anchored to the substrate.

**Solution**: Rewrite `applyRetractionForces` to pull the *rest of the body* towards the extended pseudopod, rather than pulling the pseudopod back.

**Status**: [x] **FIXED**: Replaced `ECMLocomotionSystem.cpp::applyRetractionForces()` with "Body Pull" implementation that:
1. Calculates vector from Center-of-Mass to Target Vertex (the foot)
2. Applies "Drag" velocity to all vertices EXCEPT the target vertex
3. Target vertex stays "anchored" (friction handles this)
4. Rest of body slides towards the foot

**Reference**: [Amoeba Proteus locomotion](https://www.youtube.com/watch?v=7pR7TNzJ_pA) demonstrates the specific "step-anchor-pull" motion.

---

### Note on Scaling

The "test entities are like 50x larger" observation is an optical illusion caused by camera setup:
- Camera is fixed at `Y = 22.0`
- World boundaries are calculated based on window size
- **Result**: If you maximize the window, microbes stay the same size (in pixels) but the "Petri dish" walls move further out
- Microbes are physically `0.375` units. Screen height covers about `20` units
- A microbe is roughly `1/50th` of the screen height. This is intentional (Micro-Idle)

---

---

## Architecture Overview

**New Approach: "The Puppet"**

A clean separation between physics simulation and visual rendering:

1. **Physics Layer (Jolt)**: Low-resolution soft body (icosphere, 32-64 vertices)
   - Point cloud held together by distance constraints
   - Volume constraint for internal pressure
   - Collides with world and other entities
   - Invisible to player (pure physics driver)

2. **The Bridge**: Data transport system
   - Extract vertex positions from Jolt every frame
   - Flatten to shader-compatible format
   - Update GPU uniforms

3. **Rendering Layer (SDF Raymarcher)**: Smooth organic skin
   - GPU fragment shader raymarches through volume
   - SDF smooth union of all vertex positions
   - Renders smooth blob over physics point cloud
   - No mesh drawing - pure procedural rendering

**Tech Stack**:
- **Language**: C++20
- **Build**: CMake with FetchContent
- **Framework**: Raylib 5.5 (windowing, input, rendering)
- **Physics**: Jolt Physics (multi-threaded CPU soft bodies)
- **ECS**: FLECS (Entity Component System)

**Platforms**: Windows (primary), Linux, macOS

---

## Phase 0: Refactor Amoeba Simulation for Biological Accuracy

**Status**: [x] **IN PROGRESS** - Critical bug fixes and locomotion improvements (2025-01-27)

**Current Focus**: Applying physics fixes (gravity, friction, damping) and implementing Body Pull locomotion. Removing all legacy XPBD/C code to enforce C++20/FLECS/Jolt architecture.

**Objective**: Eliminate rendering artifacts and replace "floating/pushing" locomotion with biologically accurate "grip-and-stretch" friction-based model.

### Phase 0.1: Rendering Artifact Elimination

**Target File**: `shaders/sdf_membrane.frag`

- [x] **Fix Skeleton Detachment (Blobbing)**
  - Increased `smoothness` (k) parameter from `0.5` to **1.2** in `sdMembrane()`
  - Smooth minimum function maintains continuous field when skeletal nodes stretch far apart

- [x] **Fix Hard Edges (Precision)**
  - Reduced `surfDist` (epsilon) from `0.01` to **0.001** in `raymarch()`
  - Increased `maxSteps` from `64` to **128** to accommodate finer step size
  - Reduced normal sampling epsilon `eps` from `0.001` to **0.0001** in `calcNormal()`

- [ ] **Optimize Visual Volume**
  - Adjust `baseRadius` logic to ensure membrane doesn't vanish at high stretch (TODO: test and tune)
  - Test with extreme pseudopod extensions

### Phase 0.2: Jolt Physics Architecture (Internal Motor Model)

**Target Files**: `src/systems/SoftBodyFactory.cpp`, `src/systems/PhysicsSystem.h/cpp`

- [x] **Refactor `CreateAmoeba` for High Friction**
  - Set `creationSettings.mFriction` to **20.0f** (MAX) - skin must anchor to ground
  - Decreased `creationSettings.mPressure` to **5.0f** (from 20.0f) AND increased `creationSettings.mGravityFactor` to **5.0f** for pancake/drape effect
  - Increased `mLinearDamping` to **0.8f** to kill momentum immediately when thrust stops

- [x] **Implement Internal Rigid Skeleton**
  - Added new collision layers to `PhysicsSystem.h`:
    - `SKIN` layer: Collides with Ground (Static) and Skeleton
    - `SKELETON` layer: Collides with Skin (Inside) but **IGNORES Ground**
  - Modified `CreateAmoeba` to instantiate distinct **JPH::RigidBody spheres** inside Soft Body volume
  - Updated collision filtering in `PhysicsSystem.cpp`:
    - Group A (Skin): Collides with Ground (Static) and Skeleton
    - Group B (Skeleton): Collides with Skin (Inside) but **IGNORES Ground**

- [x] **Update Component Structure**
  - Added `InternalSkeleton` component to `Microbe.h`:
    ```cpp
    struct InternalSkeleton {
        std::vector<JPH::BodyID> skeletonBodyIDs;  // Rigid spheres inside soft body
        int skeletonNodeCount;                      // Number of skeleton nodes
    };
    ```

### Phase 0.3: Friction-Based Locomotion

**Target File**: `src/systems/ECMLocomotionSystem.cpp`

- [x] **Refactor Force Application**
  - Changed from applying forces to soft body vertices → apply forces **ONLY to Internal Skeleton RigidBodies**
  - Mechanism implemented:
    1. Skeleton moves forward → hits interior of Skin
    2. Front of Skin stretches forward (pushed by skeleton)
    3. Bottom of Skin stays anchored (friction)
    4. Elastic constraints eventually pull rear of Skin forward

- [x] **Update EC&M Force Functions**
  - `applyExtensionForces`: Now applies `AddForce` to skeleton rigid bodies via `BodyInterface.AddForce()`
  - `applySearchForces`: Applies lateral wiggle force to skeleton nodes
  - `applyRetractionForces`: Pulls skeleton nodes back toward soft body center
  - Updated `World.cpp` to pass `InternalSkeleton` component to `ECMLocomotionSystem::update()`

### Phase 0.4: Integration & Tuning

- [ ] **Visual Validation**
  - Verify normals are smooth (no black artifacts at horizon)
  - Verify no field disconnection at extreme stretches
  - Test with high pseudopod extension

- [ ] **Physics Validation**
  - Verify amoeba does **NOT** move if gravity is zero (requires friction/gravity to crawl)
  - Verify visual mesh elongates significantly before center of mass moves
  - Test stretch behavior: membrane must elongate before effective locomotion

- [ ] **Performance Check**
  - Profile with internal skeleton (should be minimal overhead)
  - Verify collision filtering works correctly
  - Test multi-amoeba scenarios

---

## Phase 1: Clean Slate

### 1.1 Remove Legacy Code
- [x] Identify all metaball-related files
- [ ] Remove all legacy shaders (metaball_*.vert/frag, xpbd_*.vert/frag)
- [ ] Clean up legacy rendering code in src/
- [ ] Remove game/game.cpp if obsolete
- [ ] Remove any mesh-based rendering systems

### 1.2 Update Documentation
- [x] Update ARCHITECTURE.MD with Puppet/SDF architecture
- [x] Update PLAN.md (this file) with new roadmap
- [ ] Update README.md to remove metaball references

### 1.3 Verify Clean Build
- [ ] Build succeeds with remaining code
- [ ] All existing tests pass
- [ ] No compiler warnings

---

## Phase 2: Foundation - Icosphere Generation

### 2.1 Icosphere Utility
- [ ] Create `src/physics/Icosphere.h/cpp`
- [ ] Implement `GenerateIcosphere(subdivisions)` function
- [ ] Returns vertex positions and triangle indices
- [ ] Target: 32-64 vertices (1-2 subdivisions)
- [ ] Create `tests/test_icosphere.cpp`
- [ ] Verify vertex count, topology correctness

### 2.2 Constraint Generation
- [ ] Create `src/physics/Constraints.h/cpp`
- [ ] Implement `GenerateEdgeConstraints(vertices, triangles)`
- [ ] Generate distance constraints for each edge
- [ ] Implement volume constraint configuration
- [ ] Create `tests/test_constraints.cpp`

---

## Phase 3: Jolt Soft Body Integration

### 3.1 Soft Body Factory
- [ ] Create `src/systems/SoftBodyFactory.h/cpp`
- [ ] Implement `CreateSoftBodyAmoeba(world, position, scale)`
- [ ] Configure `SoftBodyCreationSettings`:
  - Icosphere vertices
  - Edge constraints
  - Volume constraint (internal pressure)
  - Material properties (friction, restitution)
- [ ] Return `JPH::BodyID`

### 3.2 Physics System Update
- [ ] Update `src/systems/PhysicsSystem.h/cpp`
- [ ] Ensure Jolt soft body support is initialized
- [ ] Configure collision filtering (soft body vs world, soft body vs soft body)
- [ ] Test single soft body creation and stepping

### 3.3 Component Definition
- [ ] Update `src/components/Physics.h`
- [ ] Define `SoftBodyComponent`:
  ```cpp
  struct SoftBodyComponent {
      JPH::BodyID bodyID;
      int vertexCount;
      float* vertexPositions;  // Flattened [x,y,z, x,y,z, ...]
  };
  ```

### 3.4 Test Soft Body
- [ ] Create `tests/test_soft_body.cpp`
- [ ] Verify soft body creation
- [ ] Verify vertex extraction works
- [ ] Test collision response
- [ ] Test volume constraint (compression/expansion)

---

## Phase 4: The Bridge - Physics to GPU

### 4.1 Data Extraction System
- [ ] Create `src/systems/UpdateSDFUniforms.h/cpp`
- [ ] Implement `System_UpdateSDFUniforms`:
  - Query entities with `SoftBodyComponent` + `SDFRenderComponent`
  - Lock Jolt BodyInterface
  - Extract vertex positions from soft body
  - Convert `JPH::RVec3` → `float[3]`
  - Flatten to contiguous array
  - Update `SoftBodyComponent.vertexPositions`

### 4.2 Shader Uniform Update
- [ ] In `System_UpdateSDFUniforms`:
  - Get shader location for `uPoints[]`
  - Call `SetShaderValueV(shader, loc, positions, SHADER_UNIFORM_VEC3, count)`
  - Update once per frame

### 4.3 Test Bridge System
- [ ] Create `tests/test_sdf_uniforms.cpp`
- [ ] Mock soft body with known positions
- [ ] Verify data extraction is correct
- [ ] Verify shader uniform format matches expectation

---

## Phase 5: SDF Raymarching Renderer

### 5.1 SDF Shaders
- [ ] Create `data/shaders/sdf_raymarch.vert`
  - Standard MVP transformation
  - Pass world position and view direction to fragment shader
- [ ] Create `data/shaders/sdf_raymarch.frag`
  - Define `uniform vec3 uPoints[64]`
  - Define `uniform int uPointCount`
  - Implement `sdSphere(p, center, radius)`
  - Implement `sdSmoothUnion(d1, d2, k)` (smin)
  - Implement `sceneSDF(p)` (loop over uPoints)
  - Implement raymarch loop
  - Implement normal calculation (SDF gradient)
  - Implement basic Blinn-Phong lighting
- [ ] Test shader compilation

### 5.2 Bounding Volume Generator
- [ ] Create `src/rendering/RaymarchBounds.h/cpp`
- [ ] Implement `GenerateBoundingCube(center, size)`
- [ ] Returns Raylib `Model` (inverted cube mesh)
- [ ] Scale to encompass soft body extents

### 5.3 SDF Render System
- [ ] Create `src/systems/SDFRenderSystem.h/cpp`
- [ ] Implement `System_SDFRender`:
  - Query entities with `Transform` + `SoftBodyComponent` + `SDFRenderComponent`
  - Set shader uniforms (already updated by UpdateSDFUniforms)
  - Bind shader
  - Draw bounding volume
  - Unbind shader

### 5.4 Component Definition
- [ ] Update `src/components/Rendering.h`
- [ ] Define `SDFRenderComponent`:
  ```cpp
  struct SDFRenderComponent {
      Shader sdfShader;
      int shaderLocPoints;
      int shaderLocPointCount;
      int shaderLocCameraPos;
      Model boundingVolume;
  };
  ```

### 5.5 Test Rendering
- [ ] Create `tests/test_sdf_render.cpp`
- [ ] Headless render test (screenshot verification)
- [ ] Verify bounding volume is drawn
- [ ] Verify shader uniforms are correctly bound
- [ ] Visual test: single static soft body renders as smooth blob

---

## Phase 6: Integration - Full Pipeline

### 6.1 Entity Creation Helper
- [ ] Create `src/World.cpp/h` helper function:
  - `CreateAmoeba(world, position, color, seed)`
  - Spawns entity with all required components
  - Creates Jolt soft body
  - Loads SDF shader
  - Generates bounding volume
  - Returns entity ID

### 6.2 Main Loop Integration
- [ ] Update `bin/main.cpp`:
  - Initialize FLECS world
  - Initialize PhysicsSystem (Jolt)
  - Register all systems in correct pipeline order:
    1. Input (OnUpdate)
    2. Physics (OnUpdate)
    3. Transform Sync (OnStore)
    4. SDF Uniform Update (OnStore)
    5. Render (PostUpdate)
  - Spawn test amoeba
  - Run main loop

### 6.3 Visual Verification
- [ ] Create `tests/visual_test.cpp`
- [ ] Spawn single amoeba
- [ ] Let physics run for 60 frames
- [ ] Capture screenshot
- [ ] Verify blob is visible and smooth
- [ ] Verify soft body deformation (if forces applied)

---

## Phase 7: EC&M Locomotion

### 7.1 EC&M Behavior System
- [ ] Create `src/systems/ECMBehaviorSystem.h/cpp`
- [ ] Implement `System_AmoebaBehavior`:
  - Query entities with `ECMLocomotion` + `SoftBodyComponent`
  - Update phase: `ecm.phase += dt / CYCLE_DURATION`
  - State machine:
    - **Extend** (0.0 - 0.4): Apply outward force to target vertex
    - **Search** (0.4 - 0.7): Apply lateral wiggle forces
    - **Retract** (0.7 - 1.0): Apply inward force to all vertices
  - Pseudopod selection: choose vertex on leading edge
  - Apply forces via `BodyInterface.AddForce(bodyID, vertexIndex, force)`

### 7.2 Component Definition
- [ ] Update `src/components/Microbe.h`
- [ ] Define `ECMLocomotion`:
  ```cpp
  struct ECMLocomotion {
      float phase;              // 0.0 - 1.0
      int pseudopodTarget;      // Vertex index
      Vec3 pseudopodDir;        // Extension direction
      float cycleTime;          // 12 seconds default
  };
  ```

### 7.3 Test EC&M
- [ ] Create `tests/test_ecm_locomotion.cpp`
- [ ] Verify phase progression
- [ ] Verify force application at correct vertices
- [ ] Visual test: amoeba extends pseudopod, wiggles, retracts
- [ ] Verify net displacement over multiple cycles

---

## Phase 8: Collision & Multi-Entity

### 8.1 Collision Configuration
- [ ] Configure Jolt collision layers:
  - Soft body vertices collide with ground
  - Soft body vertices collide with other soft body vertices
  - Test collision filtering

### 8.2 Ground Plane
- [ ] Create static ground plane (Jolt box body)
- [ ] Verify soft bodies rest on ground
- [ ] Verify soft deformation on impact

### 8.3 Multi-Entity Test
- [ ] Spawn 2-3 amoebas in proximity
- [ ] Verify inter-amoeba collision
- [ ] Verify soft squishing behavior
- [ ] Verify separation after collision
- [ ] Visual test: amoebas collide and deform realistically

---

## Phase 9: Polish & Optimization

### 9.1 Shader Optimization
- [ ] Profile fragment shader performance
- [ ] Optimize raymarch step count
- [ ] Implement early ray termination
- [ ] Add bounding sphere culling

### 9.2 Camera System
- [ ] Implement simple camera controller
- [ ] Orbit camera around scene
- [ ] Zoom in/out
- [ ] Lock to 2D plane (top-down view)

### 9.3 Visual Polish
- [ ] Tune SDF smoothness parameter
- [ ] Tune vertex radius for desired blob appearance
- [ ] Add color variation per microbe
- [ ] Test different lighting models (ambient, diffuse, specular)

### 9.4 Performance Testing
- [ ] Spawn 10+ amoebas
- [ ] Profile frame time
- [ ] Profile physics time
- [ ] Profile render time
- [ ] Identify bottlenecks
- [ ] Optimize as needed

---

## Phase 10: Future Extensions

### 10.1 Additional Microbe Types
- [ ] Stentor (elongated soft body)
- [ ] Heliozoa (spikes via separate rigid bodies)
- [ ] Different icosphere resolutions per type

### 10.2 Rendering Variations
- [ ] Type-specific shader variants
- [ ] Internal structure rendering (skeleton nodes)
- [ ] Transparency/alpha blending

### 10.3 Gameplay Systems
- [ ] Resource drops on destruction
- [ ] Player interaction (click to destroy)
- [ ] Spawning system

---

## Key Files

**Docs**: README.md, ARCHITECTURE.MD, PLAN.md (this file)
**Build**: CMakeLists.txt, bin/build.sh
**Components**: src/components/*.h
**Systems**: src/systems/*.cpp
**Shaders**: data/shaders/sdf_raymarch.*
**Main**: bin/main.cpp

---

## Cleanup Checklist

Files to DELETE:
- [x] Identified legacy shader files (metaball_*, xpbd_*)
- [ ] `data/shaders/metaball.vert/frag`
- [ ] `data/shaders/metaball_field.vert/frag`
- [ ] `data/shaders/metaball_surface.vert/frag`
- [ ] `data/shaders/xpbd_microbe.vert/frag`
- [ ] `data/shaders/particle_simple.vert/frag`
- [ ] `data/shaders/outline.vert/frag`
- [ ] `data/shaders/outline_curve.vert/frag`
- [ ] Any obsolete mesh rendering code in src/
- [ ] Any obsolete rendering components/systems

Code to REFACTOR:
- [ ] Keep PhysicsSystem.cpp (update for soft bodies)
- [ ] Keep SoftBodyFactory.cpp (update for new approach)
- [ ] Keep ECMLocomotionSystem.cpp (update to apply forces to vertices)
- [ ] Keep World.cpp (update entity creation)
- [ ] Remove any metaball/mesh rendering code

---

## Next Immediate Steps

1. Remove all legacy shader files
2. Update README.md
3. Verify clean build
4. Begin Phase 2: Icosphere generation
